// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"learning-french-service/internal/ent/deck"
	"learning-french-service/internal/ent/predicate"
	"learning-french-service/internal/ent/pronunciationattempt"
	"learning-french-service/internal/ent/question"
	"learning-french-service/internal/ent/word"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/dialect/sql/sqljson"
	"entgo.io/ent/schema/field"
)

// WordUpdate is the builder for updating Word entities.
type WordUpdate struct {
	config
	hooks    []Hook
	mutation *WordMutation
}

// Where appends a list predicates to the WordUpdate builder.
func (_u *WordUpdate) Where(ps ...predicate.Word) *WordUpdate {
	_u.mutation.Where(ps...)
	return _u
}

// SetFrenchWord sets the "french_word" field.
func (_u *WordUpdate) SetFrenchWord(v string) *WordUpdate {
	_u.mutation.SetFrenchWord(v)
	return _u
}

// SetNillableFrenchWord sets the "french_word" field if the given value is not nil.
func (_u *WordUpdate) SetNillableFrenchWord(v *string) *WordUpdate {
	if v != nil {
		_u.SetFrenchWord(*v)
	}
	return _u
}

// SetEnglishTranslation sets the "english_translation" field.
func (_u *WordUpdate) SetEnglishTranslation(v string) *WordUpdate {
	_u.mutation.SetEnglishTranslation(v)
	return _u
}

// SetNillableEnglishTranslation sets the "english_translation" field if the given value is not nil.
func (_u *WordUpdate) SetNillableEnglishTranslation(v *string) *WordUpdate {
	if v != nil {
		_u.SetEnglishTranslation(*v)
	}
	return _u
}

// SetPartOfSpeech sets the "part_of_speech" field.
func (_u *WordUpdate) SetPartOfSpeech(v string) *WordUpdate {
	_u.mutation.SetPartOfSpeech(v)
	return _u
}

// SetNillablePartOfSpeech sets the "part_of_speech" field if the given value is not nil.
func (_u *WordUpdate) SetNillablePartOfSpeech(v *string) *WordUpdate {
	if v != nil {
		_u.SetPartOfSpeech(*v)
	}
	return _u
}

// ClearPartOfSpeech clears the value of the "part_of_speech" field.
func (_u *WordUpdate) ClearPartOfSpeech() *WordUpdate {
	_u.mutation.ClearPartOfSpeech()
	return _u
}

// SetGender sets the "gender" field.
func (_u *WordUpdate) SetGender(v string) *WordUpdate {
	_u.mutation.SetGender(v)
	return _u
}

// SetNillableGender sets the "gender" field if the given value is not nil.
func (_u *WordUpdate) SetNillableGender(v *string) *WordUpdate {
	if v != nil {
		_u.SetGender(*v)
	}
	return _u
}

// ClearGender clears the value of the "gender" field.
func (_u *WordUpdate) ClearGender() *WordUpdate {
	_u.mutation.ClearGender()
	return _u
}

// SetFrenchExample sets the "french_example" field.
func (_u *WordUpdate) SetFrenchExample(v string) *WordUpdate {
	_u.mutation.SetFrenchExample(v)
	return _u
}

// SetNillableFrenchExample sets the "french_example" field if the given value is not nil.
func (_u *WordUpdate) SetNillableFrenchExample(v *string) *WordUpdate {
	if v != nil {
		_u.SetFrenchExample(*v)
	}
	return _u
}

// ClearFrenchExample clears the value of the "french_example" field.
func (_u *WordUpdate) ClearFrenchExample() *WordUpdate {
	_u.mutation.ClearFrenchExample()
	return _u
}

// SetEnglishExampleTranslation sets the "english_example_translation" field.
func (_u *WordUpdate) SetEnglishExampleTranslation(v string) *WordUpdate {
	_u.mutation.SetEnglishExampleTranslation(v)
	return _u
}

// SetNillableEnglishExampleTranslation sets the "english_example_translation" field if the given value is not nil.
func (_u *WordUpdate) SetNillableEnglishExampleTranslation(v *string) *WordUpdate {
	if v != nil {
		_u.SetEnglishExampleTranslation(*v)
	}
	return _u
}

// ClearEnglishExampleTranslation clears the value of the "english_example_translation" field.
func (_u *WordUpdate) ClearEnglishExampleTranslation() *WordUpdate {
	_u.mutation.ClearEnglishExampleTranslation()
	return _u
}

// SetPhoneticTranscription sets the "phonetic_transcription" field.
func (_u *WordUpdate) SetPhoneticTranscription(v string) *WordUpdate {
	_u.mutation.SetPhoneticTranscription(v)
	return _u
}

// SetNillablePhoneticTranscription sets the "phonetic_transcription" field if the given value is not nil.
func (_u *WordUpdate) SetNillablePhoneticTranscription(v *string) *WordUpdate {
	if v != nil {
		_u.SetPhoneticTranscription(*v)
	}
	return _u
}

// ClearPhoneticTranscription clears the value of the "phonetic_transcription" field.
func (_u *WordUpdate) ClearPhoneticTranscription() *WordUpdate {
	_u.mutation.ClearPhoneticTranscription()
	return _u
}

// SetPronunciationAudioURL sets the "pronunciation_audio_url" field.
func (_u *WordUpdate) SetPronunciationAudioURL(v string) *WordUpdate {
	_u.mutation.SetPronunciationAudioURL(v)
	return _u
}

// SetNillablePronunciationAudioURL sets the "pronunciation_audio_url" field if the given value is not nil.
func (_u *WordUpdate) SetNillablePronunciationAudioURL(v *string) *WordUpdate {
	if v != nil {
		_u.SetPronunciationAudioURL(*v)
	}
	return _u
}

// ClearPronunciationAudioURL clears the value of the "pronunciation_audio_url" field.
func (_u *WordUpdate) ClearPronunciationAudioURL() *WordUpdate {
	_u.mutation.ClearPronunciationAudioURL()
	return _u
}

// SetDifficultyLevel sets the "difficulty_level" field.
func (_u *WordUpdate) SetDifficultyLevel(v string) *WordUpdate {
	_u.mutation.SetDifficultyLevel(v)
	return _u
}

// SetNillableDifficultyLevel sets the "difficulty_level" field if the given value is not nil.
func (_u *WordUpdate) SetNillableDifficultyLevel(v *string) *WordUpdate {
	if v != nil {
		_u.SetDifficultyLevel(*v)
	}
	return _u
}

// ClearDifficultyLevel clears the value of the "difficulty_level" field.
func (_u *WordUpdate) ClearDifficultyLevel() *WordUpdate {
	_u.mutation.ClearDifficultyLevel()
	return _u
}

// SetTags sets the "tags" field.
func (_u *WordUpdate) SetTags(v []string) *WordUpdate {
	_u.mutation.SetTags(v)
	return _u
}

// AppendTags appends value to the "tags" field.
func (_u *WordUpdate) AppendTags(v []string) *WordUpdate {
	_u.mutation.AppendTags(v)
	return _u
}

// ClearTags clears the value of the "tags" field.
func (_u *WordUpdate) ClearTags() *WordUpdate {
	_u.mutation.ClearTags()
	return _u
}

// SetUsageContext sets the "usage_context" field.
func (_u *WordUpdate) SetUsageContext(v string) *WordUpdate {
	_u.mutation.SetUsageContext(v)
	return _u
}

// SetNillableUsageContext sets the "usage_context" field if the given value is not nil.
func (_u *WordUpdate) SetNillableUsageContext(v *string) *WordUpdate {
	if v != nil {
		_u.SetUsageContext(*v)
	}
	return _u
}

// ClearUsageContext clears the value of the "usage_context" field.
func (_u *WordUpdate) ClearUsageContext() *WordUpdate {
	_u.mutation.ClearUsageContext()
	return _u
}

// SetIsActive sets the "is_active" field.
func (_u *WordUpdate) SetIsActive(v bool) *WordUpdate {
	_u.mutation.SetIsActive(v)
	return _u
}

// SetNillableIsActive sets the "is_active" field if the given value is not nil.
func (_u *WordUpdate) SetNillableIsActive(v *bool) *WordUpdate {
	if v != nil {
		_u.SetIsActive(*v)
	}
	return _u
}

// SetCreatedAt sets the "created_at" field.
func (_u *WordUpdate) SetCreatedAt(v time.Time) *WordUpdate {
	_u.mutation.SetCreatedAt(v)
	return _u
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (_u *WordUpdate) SetNillableCreatedAt(v *time.Time) *WordUpdate {
	if v != nil {
		_u.SetCreatedAt(*v)
	}
	return _u
}

// SetUpdatedAt sets the "updated_at" field.
func (_u *WordUpdate) SetUpdatedAt(v time.Time) *WordUpdate {
	_u.mutation.SetUpdatedAt(v)
	return _u
}

// SetDeckID sets the "deck" edge to the Deck entity by ID.
func (_u *WordUpdate) SetDeckID(id int) *WordUpdate {
	_u.mutation.SetDeckID(id)
	return _u
}

// SetDeck sets the "deck" edge to the Deck entity.
func (_u *WordUpdate) SetDeck(v *Deck) *WordUpdate {
	return _u.SetDeckID(v.ID)
}

// AddQuestionIDs adds the "questions" edge to the Question entity by IDs.
func (_u *WordUpdate) AddQuestionIDs(ids ...int) *WordUpdate {
	_u.mutation.AddQuestionIDs(ids...)
	return _u
}

// AddQuestions adds the "questions" edges to the Question entity.
func (_u *WordUpdate) AddQuestions(v ...*Question) *WordUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddQuestionIDs(ids...)
}

// AddPronunciationAttemptIDs adds the "pronunciation_attempts" edge to the PronunciationAttempt entity by IDs.
func (_u *WordUpdate) AddPronunciationAttemptIDs(ids ...int) *WordUpdate {
	_u.mutation.AddPronunciationAttemptIDs(ids...)
	return _u
}

// AddPronunciationAttempts adds the "pronunciation_attempts" edges to the PronunciationAttempt entity.
func (_u *WordUpdate) AddPronunciationAttempts(v ...*PronunciationAttempt) *WordUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddPronunciationAttemptIDs(ids...)
}

// Mutation returns the WordMutation object of the builder.
func (_u *WordUpdate) Mutation() *WordMutation {
	return _u.mutation
}

// ClearDeck clears the "deck" edge to the Deck entity.
func (_u *WordUpdate) ClearDeck() *WordUpdate {
	_u.mutation.ClearDeck()
	return _u
}

// ClearQuestions clears all "questions" edges to the Question entity.
func (_u *WordUpdate) ClearQuestions() *WordUpdate {
	_u.mutation.ClearQuestions()
	return _u
}

// RemoveQuestionIDs removes the "questions" edge to Question entities by IDs.
func (_u *WordUpdate) RemoveQuestionIDs(ids ...int) *WordUpdate {
	_u.mutation.RemoveQuestionIDs(ids...)
	return _u
}

// RemoveQuestions removes "questions" edges to Question entities.
func (_u *WordUpdate) RemoveQuestions(v ...*Question) *WordUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveQuestionIDs(ids...)
}

// ClearPronunciationAttempts clears all "pronunciation_attempts" edges to the PronunciationAttempt entity.
func (_u *WordUpdate) ClearPronunciationAttempts() *WordUpdate {
	_u.mutation.ClearPronunciationAttempts()
	return _u
}

// RemovePronunciationAttemptIDs removes the "pronunciation_attempts" edge to PronunciationAttempt entities by IDs.
func (_u *WordUpdate) RemovePronunciationAttemptIDs(ids ...int) *WordUpdate {
	_u.mutation.RemovePronunciationAttemptIDs(ids...)
	return _u
}

// RemovePronunciationAttempts removes "pronunciation_attempts" edges to PronunciationAttempt entities.
func (_u *WordUpdate) RemovePronunciationAttempts(v ...*PronunciationAttempt) *WordUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemovePronunciationAttemptIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (_u *WordUpdate) Save(ctx context.Context) (int, error) {
	_u.defaults()
	return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (_u *WordUpdate) SaveX(ctx context.Context) int {
	affected, err := _u.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (_u *WordUpdate) Exec(ctx context.Context) error {
	_, err := _u.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (_u *WordUpdate) ExecX(ctx context.Context) {
	if err := _u.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (_u *WordUpdate) defaults() {
	if _, ok := _u.mutation.UpdatedAt(); !ok {
		v := word.UpdateDefaultUpdatedAt()
		_u.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (_u *WordUpdate) check() error {
	if v, ok := _u.mutation.FrenchWord(); ok {
		if err := word.FrenchWordValidator(v); err != nil {
			return &ValidationError{Name: "french_word", err: fmt.Errorf(`ent: validator failed for field "Word.french_word": %w`, err)}
		}
	}
	if v, ok := _u.mutation.PartOfSpeech(); ok {
		if err := word.PartOfSpeechValidator(v); err != nil {
			return &ValidationError{Name: "part_of_speech", err: fmt.Errorf(`ent: validator failed for field "Word.part_of_speech": %w`, err)}
		}
	}
	if v, ok := _u.mutation.Gender(); ok {
		if err := word.GenderValidator(v); err != nil {
			return &ValidationError{Name: "gender", err: fmt.Errorf(`ent: validator failed for field "Word.gender": %w`, err)}
		}
	}
	if v, ok := _u.mutation.PhoneticTranscription(); ok {
		if err := word.PhoneticTranscriptionValidator(v); err != nil {
			return &ValidationError{Name: "phonetic_transcription", err: fmt.Errorf(`ent: validator failed for field "Word.phonetic_transcription": %w`, err)}
		}
	}
	if v, ok := _u.mutation.PronunciationAudioURL(); ok {
		if err := word.PronunciationAudioURLValidator(v); err != nil {
			return &ValidationError{Name: "pronunciation_audio_url", err: fmt.Errorf(`ent: validator failed for field "Word.pronunciation_audio_url": %w`, err)}
		}
	}
	if v, ok := _u.mutation.DifficultyLevel(); ok {
		if err := word.DifficultyLevelValidator(v); err != nil {
			return &ValidationError{Name: "difficulty_level", err: fmt.Errorf(`ent: validator failed for field "Word.difficulty_level": %w`, err)}
		}
	}
	if _u.mutation.DeckCleared() && len(_u.mutation.DeckIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "Word.deck"`)
	}
	return nil
}

func (_u *WordUpdate) sqlSave(ctx context.Context) (_node int, err error) {
	if err := _u.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(word.Table, word.Columns, sqlgraph.NewFieldSpec(word.FieldID, field.TypeInt))
	if ps := _u.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := _u.mutation.FrenchWord(); ok {
		_spec.SetField(word.FieldFrenchWord, field.TypeString, value)
	}
	if value, ok := _u.mutation.EnglishTranslation(); ok {
		_spec.SetField(word.FieldEnglishTranslation, field.TypeString, value)
	}
	if value, ok := _u.mutation.PartOfSpeech(); ok {
		_spec.SetField(word.FieldPartOfSpeech, field.TypeString, value)
	}
	if _u.mutation.PartOfSpeechCleared() {
		_spec.ClearField(word.FieldPartOfSpeech, field.TypeString)
	}
	if value, ok := _u.mutation.Gender(); ok {
		_spec.SetField(word.FieldGender, field.TypeString, value)
	}
	if _u.mutation.GenderCleared() {
		_spec.ClearField(word.FieldGender, field.TypeString)
	}
	if value, ok := _u.mutation.FrenchExample(); ok {
		_spec.SetField(word.FieldFrenchExample, field.TypeString, value)
	}
	if _u.mutation.FrenchExampleCleared() {
		_spec.ClearField(word.FieldFrenchExample, field.TypeString)
	}
	if value, ok := _u.mutation.EnglishExampleTranslation(); ok {
		_spec.SetField(word.FieldEnglishExampleTranslation, field.TypeString, value)
	}
	if _u.mutation.EnglishExampleTranslationCleared() {
		_spec.ClearField(word.FieldEnglishExampleTranslation, field.TypeString)
	}
	if value, ok := _u.mutation.PhoneticTranscription(); ok {
		_spec.SetField(word.FieldPhoneticTranscription, field.TypeString, value)
	}
	if _u.mutation.PhoneticTranscriptionCleared() {
		_spec.ClearField(word.FieldPhoneticTranscription, field.TypeString)
	}
	if value, ok := _u.mutation.PronunciationAudioURL(); ok {
		_spec.SetField(word.FieldPronunciationAudioURL, field.TypeString, value)
	}
	if _u.mutation.PronunciationAudioURLCleared() {
		_spec.ClearField(word.FieldPronunciationAudioURL, field.TypeString)
	}
	if value, ok := _u.mutation.DifficultyLevel(); ok {
		_spec.SetField(word.FieldDifficultyLevel, field.TypeString, value)
	}
	if _u.mutation.DifficultyLevelCleared() {
		_spec.ClearField(word.FieldDifficultyLevel, field.TypeString)
	}
	if value, ok := _u.mutation.Tags(); ok {
		_spec.SetField(word.FieldTags, field.TypeJSON, value)
	}
	if value, ok := _u.mutation.AppendedTags(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, word.FieldTags, value)
		})
	}
	if _u.mutation.TagsCleared() {
		_spec.ClearField(word.FieldTags, field.TypeJSON)
	}
	if value, ok := _u.mutation.UsageContext(); ok {
		_spec.SetField(word.FieldUsageContext, field.TypeString, value)
	}
	if _u.mutation.UsageContextCleared() {
		_spec.ClearField(word.FieldUsageContext, field.TypeString)
	}
	if value, ok := _u.mutation.IsActive(); ok {
		_spec.SetField(word.FieldIsActive, field.TypeBool, value)
	}
	if value, ok := _u.mutation.CreatedAt(); ok {
		_spec.SetField(word.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := _u.mutation.UpdatedAt(); ok {
		_spec.SetField(word.FieldUpdatedAt, field.TypeTime, value)
	}
	if _u.mutation.DeckCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   word.DeckTable,
			Columns: []string{word.DeckColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(deck.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.DeckIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   word.DeckTable,
			Columns: []string{word.DeckColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(deck.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.QuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   word.QuestionsTable,
			Columns: []string{word.QuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(question.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedQuestionsIDs(); len(nodes) > 0 && !_u.mutation.QuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   word.QuestionsTable,
			Columns: []string{word.QuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(question.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.QuestionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   word.QuestionsTable,
			Columns: []string{word.QuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(question.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.PronunciationAttemptsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   word.PronunciationAttemptsTable,
			Columns: []string{word.PronunciationAttemptsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pronunciationattempt.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedPronunciationAttemptsIDs(); len(nodes) > 0 && !_u.mutation.PronunciationAttemptsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   word.PronunciationAttemptsTable,
			Columns: []string{word.PronunciationAttemptsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pronunciationattempt.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.PronunciationAttemptsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   word.PronunciationAttemptsTable,
			Columns: []string{word.PronunciationAttemptsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pronunciationattempt.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _node, err = sqlgraph.UpdateNodes(ctx, _u.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{word.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	_u.mutation.done = true
	return _node, nil
}

// WordUpdateOne is the builder for updating a single Word entity.
type WordUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *WordMutation
}

// SetFrenchWord sets the "french_word" field.
func (_u *WordUpdateOne) SetFrenchWord(v string) *WordUpdateOne {
	_u.mutation.SetFrenchWord(v)
	return _u
}

// SetNillableFrenchWord sets the "french_word" field if the given value is not nil.
func (_u *WordUpdateOne) SetNillableFrenchWord(v *string) *WordUpdateOne {
	if v != nil {
		_u.SetFrenchWord(*v)
	}
	return _u
}

// SetEnglishTranslation sets the "english_translation" field.
func (_u *WordUpdateOne) SetEnglishTranslation(v string) *WordUpdateOne {
	_u.mutation.SetEnglishTranslation(v)
	return _u
}

// SetNillableEnglishTranslation sets the "english_translation" field if the given value is not nil.
func (_u *WordUpdateOne) SetNillableEnglishTranslation(v *string) *WordUpdateOne {
	if v != nil {
		_u.SetEnglishTranslation(*v)
	}
	return _u
}

// SetPartOfSpeech sets the "part_of_speech" field.
func (_u *WordUpdateOne) SetPartOfSpeech(v string) *WordUpdateOne {
	_u.mutation.SetPartOfSpeech(v)
	return _u
}

// SetNillablePartOfSpeech sets the "part_of_speech" field if the given value is not nil.
func (_u *WordUpdateOne) SetNillablePartOfSpeech(v *string) *WordUpdateOne {
	if v != nil {
		_u.SetPartOfSpeech(*v)
	}
	return _u
}

// ClearPartOfSpeech clears the value of the "part_of_speech" field.
func (_u *WordUpdateOne) ClearPartOfSpeech() *WordUpdateOne {
	_u.mutation.ClearPartOfSpeech()
	return _u
}

// SetGender sets the "gender" field.
func (_u *WordUpdateOne) SetGender(v string) *WordUpdateOne {
	_u.mutation.SetGender(v)
	return _u
}

// SetNillableGender sets the "gender" field if the given value is not nil.
func (_u *WordUpdateOne) SetNillableGender(v *string) *WordUpdateOne {
	if v != nil {
		_u.SetGender(*v)
	}
	return _u
}

// ClearGender clears the value of the "gender" field.
func (_u *WordUpdateOne) ClearGender() *WordUpdateOne {
	_u.mutation.ClearGender()
	return _u
}

// SetFrenchExample sets the "french_example" field.
func (_u *WordUpdateOne) SetFrenchExample(v string) *WordUpdateOne {
	_u.mutation.SetFrenchExample(v)
	return _u
}

// SetNillableFrenchExample sets the "french_example" field if the given value is not nil.
func (_u *WordUpdateOne) SetNillableFrenchExample(v *string) *WordUpdateOne {
	if v != nil {
		_u.SetFrenchExample(*v)
	}
	return _u
}

// ClearFrenchExample clears the value of the "french_example" field.
func (_u *WordUpdateOne) ClearFrenchExample() *WordUpdateOne {
	_u.mutation.ClearFrenchExample()
	return _u
}

// SetEnglishExampleTranslation sets the "english_example_translation" field.
func (_u *WordUpdateOne) SetEnglishExampleTranslation(v string) *WordUpdateOne {
	_u.mutation.SetEnglishExampleTranslation(v)
	return _u
}

// SetNillableEnglishExampleTranslation sets the "english_example_translation" field if the given value is not nil.
func (_u *WordUpdateOne) SetNillableEnglishExampleTranslation(v *string) *WordUpdateOne {
	if v != nil {
		_u.SetEnglishExampleTranslation(*v)
	}
	return _u
}

// ClearEnglishExampleTranslation clears the value of the "english_example_translation" field.
func (_u *WordUpdateOne) ClearEnglishExampleTranslation() *WordUpdateOne {
	_u.mutation.ClearEnglishExampleTranslation()
	return _u
}

// SetPhoneticTranscription sets the "phonetic_transcription" field.
func (_u *WordUpdateOne) SetPhoneticTranscription(v string) *WordUpdateOne {
	_u.mutation.SetPhoneticTranscription(v)
	return _u
}

// SetNillablePhoneticTranscription sets the "phonetic_transcription" field if the given value is not nil.
func (_u *WordUpdateOne) SetNillablePhoneticTranscription(v *string) *WordUpdateOne {
	if v != nil {
		_u.SetPhoneticTranscription(*v)
	}
	return _u
}

// ClearPhoneticTranscription clears the value of the "phonetic_transcription" field.
func (_u *WordUpdateOne) ClearPhoneticTranscription() *WordUpdateOne {
	_u.mutation.ClearPhoneticTranscription()
	return _u
}

// SetPronunciationAudioURL sets the "pronunciation_audio_url" field.
func (_u *WordUpdateOne) SetPronunciationAudioURL(v string) *WordUpdateOne {
	_u.mutation.SetPronunciationAudioURL(v)
	return _u
}

// SetNillablePronunciationAudioURL sets the "pronunciation_audio_url" field if the given value is not nil.
func (_u *WordUpdateOne) SetNillablePronunciationAudioURL(v *string) *WordUpdateOne {
	if v != nil {
		_u.SetPronunciationAudioURL(*v)
	}
	return _u
}

// ClearPronunciationAudioURL clears the value of the "pronunciation_audio_url" field.
func (_u *WordUpdateOne) ClearPronunciationAudioURL() *WordUpdateOne {
	_u.mutation.ClearPronunciationAudioURL()
	return _u
}

// SetDifficultyLevel sets the "difficulty_level" field.
func (_u *WordUpdateOne) SetDifficultyLevel(v string) *WordUpdateOne {
	_u.mutation.SetDifficultyLevel(v)
	return _u
}

// SetNillableDifficultyLevel sets the "difficulty_level" field if the given value is not nil.
func (_u *WordUpdateOne) SetNillableDifficultyLevel(v *string) *WordUpdateOne {
	if v != nil {
		_u.SetDifficultyLevel(*v)
	}
	return _u
}

// ClearDifficultyLevel clears the value of the "difficulty_level" field.
func (_u *WordUpdateOne) ClearDifficultyLevel() *WordUpdateOne {
	_u.mutation.ClearDifficultyLevel()
	return _u
}

// SetTags sets the "tags" field.
func (_u *WordUpdateOne) SetTags(v []string) *WordUpdateOne {
	_u.mutation.SetTags(v)
	return _u
}

// AppendTags appends value to the "tags" field.
func (_u *WordUpdateOne) AppendTags(v []string) *WordUpdateOne {
	_u.mutation.AppendTags(v)
	return _u
}

// ClearTags clears the value of the "tags" field.
func (_u *WordUpdateOne) ClearTags() *WordUpdateOne {
	_u.mutation.ClearTags()
	return _u
}

// SetUsageContext sets the "usage_context" field.
func (_u *WordUpdateOne) SetUsageContext(v string) *WordUpdateOne {
	_u.mutation.SetUsageContext(v)
	return _u
}

// SetNillableUsageContext sets the "usage_context" field if the given value is not nil.
func (_u *WordUpdateOne) SetNillableUsageContext(v *string) *WordUpdateOne {
	if v != nil {
		_u.SetUsageContext(*v)
	}
	return _u
}

// ClearUsageContext clears the value of the "usage_context" field.
func (_u *WordUpdateOne) ClearUsageContext() *WordUpdateOne {
	_u.mutation.ClearUsageContext()
	return _u
}

// SetIsActive sets the "is_active" field.
func (_u *WordUpdateOne) SetIsActive(v bool) *WordUpdateOne {
	_u.mutation.SetIsActive(v)
	return _u
}

// SetNillableIsActive sets the "is_active" field if the given value is not nil.
func (_u *WordUpdateOne) SetNillableIsActive(v *bool) *WordUpdateOne {
	if v != nil {
		_u.SetIsActive(*v)
	}
	return _u
}

// SetCreatedAt sets the "created_at" field.
func (_u *WordUpdateOne) SetCreatedAt(v time.Time) *WordUpdateOne {
	_u.mutation.SetCreatedAt(v)
	return _u
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (_u *WordUpdateOne) SetNillableCreatedAt(v *time.Time) *WordUpdateOne {
	if v != nil {
		_u.SetCreatedAt(*v)
	}
	return _u
}

// SetUpdatedAt sets the "updated_at" field.
func (_u *WordUpdateOne) SetUpdatedAt(v time.Time) *WordUpdateOne {
	_u.mutation.SetUpdatedAt(v)
	return _u
}

// SetDeckID sets the "deck" edge to the Deck entity by ID.
func (_u *WordUpdateOne) SetDeckID(id int) *WordUpdateOne {
	_u.mutation.SetDeckID(id)
	return _u
}

// SetDeck sets the "deck" edge to the Deck entity.
func (_u *WordUpdateOne) SetDeck(v *Deck) *WordUpdateOne {
	return _u.SetDeckID(v.ID)
}

// AddQuestionIDs adds the "questions" edge to the Question entity by IDs.
func (_u *WordUpdateOne) AddQuestionIDs(ids ...int) *WordUpdateOne {
	_u.mutation.AddQuestionIDs(ids...)
	return _u
}

// AddQuestions adds the "questions" edges to the Question entity.
func (_u *WordUpdateOne) AddQuestions(v ...*Question) *WordUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddQuestionIDs(ids...)
}

// AddPronunciationAttemptIDs adds the "pronunciation_attempts" edge to the PronunciationAttempt entity by IDs.
func (_u *WordUpdateOne) AddPronunciationAttemptIDs(ids ...int) *WordUpdateOne {
	_u.mutation.AddPronunciationAttemptIDs(ids...)
	return _u
}

// AddPronunciationAttempts adds the "pronunciation_attempts" edges to the PronunciationAttempt entity.
func (_u *WordUpdateOne) AddPronunciationAttempts(v ...*PronunciationAttempt) *WordUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddPronunciationAttemptIDs(ids...)
}

// Mutation returns the WordMutation object of the builder.
func (_u *WordUpdateOne) Mutation() *WordMutation {
	return _u.mutation
}

// ClearDeck clears the "deck" edge to the Deck entity.
func (_u *WordUpdateOne) ClearDeck() *WordUpdateOne {
	_u.mutation.ClearDeck()
	return _u
}

// ClearQuestions clears all "questions" edges to the Question entity.
func (_u *WordUpdateOne) ClearQuestions() *WordUpdateOne {
	_u.mutation.ClearQuestions()
	return _u
}

// RemoveQuestionIDs removes the "questions" edge to Question entities by IDs.
func (_u *WordUpdateOne) RemoveQuestionIDs(ids ...int) *WordUpdateOne {
	_u.mutation.RemoveQuestionIDs(ids...)
	return _u
}

// RemoveQuestions removes "questions" edges to Question entities.
func (_u *WordUpdateOne) RemoveQuestions(v ...*Question) *WordUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveQuestionIDs(ids...)
}

// ClearPronunciationAttempts clears all "pronunciation_attempts" edges to the PronunciationAttempt entity.
func (_u *WordUpdateOne) ClearPronunciationAttempts() *WordUpdateOne {
	_u.mutation.ClearPronunciationAttempts()
	return _u
}

// RemovePronunciationAttemptIDs removes the "pronunciation_attempts" edge to PronunciationAttempt entities by IDs.
func (_u *WordUpdateOne) RemovePronunciationAttemptIDs(ids ...int) *WordUpdateOne {
	_u.mutation.RemovePronunciationAttemptIDs(ids...)
	return _u
}

// RemovePronunciationAttempts removes "pronunciation_attempts" edges to PronunciationAttempt entities.
func (_u *WordUpdateOne) RemovePronunciationAttempts(v ...*PronunciationAttempt) *WordUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemovePronunciationAttemptIDs(ids...)
}

// Where appends a list predicates to the WordUpdate builder.
func (_u *WordUpdateOne) Where(ps ...predicate.Word) *WordUpdateOne {
	_u.mutation.Where(ps...)
	return _u
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (_u *WordUpdateOne) Select(field string, fields ...string) *WordUpdateOne {
	_u.fields = append([]string{field}, fields...)
	return _u
}

// Save executes the query and returns the updated Word entity.
func (_u *WordUpdateOne) Save(ctx context.Context) (*Word, error) {
	_u.defaults()
	return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (_u *WordUpdateOne) SaveX(ctx context.Context) *Word {
	node, err := _u.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (_u *WordUpdateOne) Exec(ctx context.Context) error {
	_, err := _u.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (_u *WordUpdateOne) ExecX(ctx context.Context) {
	if err := _u.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (_u *WordUpdateOne) defaults() {
	if _, ok := _u.mutation.UpdatedAt(); !ok {
		v := word.UpdateDefaultUpdatedAt()
		_u.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (_u *WordUpdateOne) check() error {
	if v, ok := _u.mutation.FrenchWord(); ok {
		if err := word.FrenchWordValidator(v); err != nil {
			return &ValidationError{Name: "french_word", err: fmt.Errorf(`ent: validator failed for field "Word.french_word": %w`, err)}
		}
	}
	if v, ok := _u.mutation.PartOfSpeech(); ok {
		if err := word.PartOfSpeechValidator(v); err != nil {
			return &ValidationError{Name: "part_of_speech", err: fmt.Errorf(`ent: validator failed for field "Word.part_of_speech": %w`, err)}
		}
	}
	if v, ok := _u.mutation.Gender(); ok {
		if err := word.GenderValidator(v); err != nil {
			return &ValidationError{Name: "gender", err: fmt.Errorf(`ent: validator failed for field "Word.gender": %w`, err)}
		}
	}
	if v, ok := _u.mutation.PhoneticTranscription(); ok {
		if err := word.PhoneticTranscriptionValidator(v); err != nil {
			return &ValidationError{Name: "phonetic_transcription", err: fmt.Errorf(`ent: validator failed for field "Word.phonetic_transcription": %w`, err)}
		}
	}
	if v, ok := _u.mutation.PronunciationAudioURL(); ok {
		if err := word.PronunciationAudioURLValidator(v); err != nil {
			return &ValidationError{Name: "pronunciation_audio_url", err: fmt.Errorf(`ent: validator failed for field "Word.pronunciation_audio_url": %w`, err)}
		}
	}
	if v, ok := _u.mutation.DifficultyLevel(); ok {
		if err := word.DifficultyLevelValidator(v); err != nil {
			return &ValidationError{Name: "difficulty_level", err: fmt.Errorf(`ent: validator failed for field "Word.difficulty_level": %w`, err)}
		}
	}
	if _u.mutation.DeckCleared() && len(_u.mutation.DeckIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "Word.deck"`)
	}
	return nil
}

func (_u *WordUpdateOne) sqlSave(ctx context.Context) (_node *Word, err error) {
	if err := _u.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(word.Table, word.Columns, sqlgraph.NewFieldSpec(word.FieldID, field.TypeInt))
	id, ok := _u.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Word.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := _u.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, word.FieldID)
		for _, f := range fields {
			if !word.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != word.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := _u.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := _u.mutation.FrenchWord(); ok {
		_spec.SetField(word.FieldFrenchWord, field.TypeString, value)
	}
	if value, ok := _u.mutation.EnglishTranslation(); ok {
		_spec.SetField(word.FieldEnglishTranslation, field.TypeString, value)
	}
	if value, ok := _u.mutation.PartOfSpeech(); ok {
		_spec.SetField(word.FieldPartOfSpeech, field.TypeString, value)
	}
	if _u.mutation.PartOfSpeechCleared() {
		_spec.ClearField(word.FieldPartOfSpeech, field.TypeString)
	}
	if value, ok := _u.mutation.Gender(); ok {
		_spec.SetField(word.FieldGender, field.TypeString, value)
	}
	if _u.mutation.GenderCleared() {
		_spec.ClearField(word.FieldGender, field.TypeString)
	}
	if value, ok := _u.mutation.FrenchExample(); ok {
		_spec.SetField(word.FieldFrenchExample, field.TypeString, value)
	}
	if _u.mutation.FrenchExampleCleared() {
		_spec.ClearField(word.FieldFrenchExample, field.TypeString)
	}
	if value, ok := _u.mutation.EnglishExampleTranslation(); ok {
		_spec.SetField(word.FieldEnglishExampleTranslation, field.TypeString, value)
	}
	if _u.mutation.EnglishExampleTranslationCleared() {
		_spec.ClearField(word.FieldEnglishExampleTranslation, field.TypeString)
	}
	if value, ok := _u.mutation.PhoneticTranscription(); ok {
		_spec.SetField(word.FieldPhoneticTranscription, field.TypeString, value)
	}
	if _u.mutation.PhoneticTranscriptionCleared() {
		_spec.ClearField(word.FieldPhoneticTranscription, field.TypeString)
	}
	if value, ok := _u.mutation.PronunciationAudioURL(); ok {
		_spec.SetField(word.FieldPronunciationAudioURL, field.TypeString, value)
	}
	if _u.mutation.PronunciationAudioURLCleared() {
		_spec.ClearField(word.FieldPronunciationAudioURL, field.TypeString)
	}
	if value, ok := _u.mutation.DifficultyLevel(); ok {
		_spec.SetField(word.FieldDifficultyLevel, field.TypeString, value)
	}
	if _u.mutation.DifficultyLevelCleared() {
		_spec.ClearField(word.FieldDifficultyLevel, field.TypeString)
	}
	if value, ok := _u.mutation.Tags(); ok {
		_spec.SetField(word.FieldTags, field.TypeJSON, value)
	}
	if value, ok := _u.mutation.AppendedTags(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, word.FieldTags, value)
		})
	}
	if _u.mutation.TagsCleared() {
		_spec.ClearField(word.FieldTags, field.TypeJSON)
	}
	if value, ok := _u.mutation.UsageContext(); ok {
		_spec.SetField(word.FieldUsageContext, field.TypeString, value)
	}
	if _u.mutation.UsageContextCleared() {
		_spec.ClearField(word.FieldUsageContext, field.TypeString)
	}
	if value, ok := _u.mutation.IsActive(); ok {
		_spec.SetField(word.FieldIsActive, field.TypeBool, value)
	}
	if value, ok := _u.mutation.CreatedAt(); ok {
		_spec.SetField(word.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := _u.mutation.UpdatedAt(); ok {
		_spec.SetField(word.FieldUpdatedAt, field.TypeTime, value)
	}
	if _u.mutation.DeckCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   word.DeckTable,
			Columns: []string{word.DeckColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(deck.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.DeckIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   word.DeckTable,
			Columns: []string{word.DeckColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(deck.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.QuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   word.QuestionsTable,
			Columns: []string{word.QuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(question.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedQuestionsIDs(); len(nodes) > 0 && !_u.mutation.QuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   word.QuestionsTable,
			Columns: []string{word.QuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(question.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.QuestionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   word.QuestionsTable,
			Columns: []string{word.QuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(question.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.PronunciationAttemptsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   word.PronunciationAttemptsTable,
			Columns: []string{word.PronunciationAttemptsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pronunciationattempt.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedPronunciationAttemptsIDs(); len(nodes) > 0 && !_u.mutation.PronunciationAttemptsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   word.PronunciationAttemptsTable,
			Columns: []string{word.PronunciationAttemptsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pronunciationattempt.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.PronunciationAttemptsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   word.PronunciationAttemptsTable,
			Columns: []string{word.PronunciationAttemptsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pronunciationattempt.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Word{config: _u.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, _u.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{word.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	_u.mutation.done = true
	return _node, nil
}
