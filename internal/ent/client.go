// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"learning-french-service/internal/ent/migrate"

	"learning-french-service/internal/ent/deck"
	"learning-french-service/internal/ent/learningstreak"
	"learning-french-service/internal/ent/pronunciationattempt"
	"learning-french-service/internal/ent/question"
	"learning-french-service/internal/ent/questionattempt"
	"learning-french-service/internal/ent/questionreview"
	"learning-french-service/internal/ent/user"
	"learning-french-service/internal/ent/userstats"
	"learning-french-service/internal/ent/word"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Deck is the client for interacting with the Deck builders.
	Deck *DeckClient
	// LearningStreak is the client for interacting with the LearningStreak builders.
	LearningStreak *LearningStreakClient
	// PronunciationAttempt is the client for interacting with the PronunciationAttempt builders.
	PronunciationAttempt *PronunciationAttemptClient
	// Question is the client for interacting with the Question builders.
	Question *QuestionClient
	// QuestionAttempt is the client for interacting with the QuestionAttempt builders.
	QuestionAttempt *QuestionAttemptClient
	// QuestionReview is the client for interacting with the QuestionReview builders.
	QuestionReview *QuestionReviewClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserStats is the client for interacting with the UserStats builders.
	UserStats *UserStatsClient
	// Word is the client for interacting with the Word builders.
	Word *WordClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Deck = NewDeckClient(c.config)
	c.LearningStreak = NewLearningStreakClient(c.config)
	c.PronunciationAttempt = NewPronunciationAttemptClient(c.config)
	c.Question = NewQuestionClient(c.config)
	c.QuestionAttempt = NewQuestionAttemptClient(c.config)
	c.QuestionReview = NewQuestionReviewClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserStats = NewUserStatsClient(c.config)
	c.Word = NewWordClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Deck:                 NewDeckClient(cfg),
		LearningStreak:       NewLearningStreakClient(cfg),
		PronunciationAttempt: NewPronunciationAttemptClient(cfg),
		Question:             NewQuestionClient(cfg),
		QuestionAttempt:      NewQuestionAttemptClient(cfg),
		QuestionReview:       NewQuestionReviewClient(cfg),
		User:                 NewUserClient(cfg),
		UserStats:            NewUserStatsClient(cfg),
		Word:                 NewWordClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Deck:                 NewDeckClient(cfg),
		LearningStreak:       NewLearningStreakClient(cfg),
		PronunciationAttempt: NewPronunciationAttemptClient(cfg),
		Question:             NewQuestionClient(cfg),
		QuestionAttempt:      NewQuestionAttemptClient(cfg),
		QuestionReview:       NewQuestionReviewClient(cfg),
		User:                 NewUserClient(cfg),
		UserStats:            NewUserStatsClient(cfg),
		Word:                 NewWordClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Deck.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Deck, c.LearningStreak, c.PronunciationAttempt, c.Question, c.QuestionAttempt,
		c.QuestionReview, c.User, c.UserStats, c.Word,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Deck, c.LearningStreak, c.PronunciationAttempt, c.Question, c.QuestionAttempt,
		c.QuestionReview, c.User, c.UserStats, c.Word,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *DeckMutation:
		return c.Deck.mutate(ctx, m)
	case *LearningStreakMutation:
		return c.LearningStreak.mutate(ctx, m)
	case *PronunciationAttemptMutation:
		return c.PronunciationAttempt.mutate(ctx, m)
	case *QuestionMutation:
		return c.Question.mutate(ctx, m)
	case *QuestionAttemptMutation:
		return c.QuestionAttempt.mutate(ctx, m)
	case *QuestionReviewMutation:
		return c.QuestionReview.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserStatsMutation:
		return c.UserStats.mutate(ctx, m)
	case *WordMutation:
		return c.Word.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// DeckClient is a client for the Deck schema.
type DeckClient struct {
	config
}

// NewDeckClient returns a client for the Deck from the given config.
func NewDeckClient(c config) *DeckClient {
	return &DeckClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `deck.Hooks(f(g(h())))`.
func (c *DeckClient) Use(hooks ...Hook) {
	c.hooks.Deck = append(c.hooks.Deck, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `deck.Intercept(f(g(h())))`.
func (c *DeckClient) Intercept(interceptors ...Interceptor) {
	c.inters.Deck = append(c.inters.Deck, interceptors...)
}

// Create returns a builder for creating a Deck entity.
func (c *DeckClient) Create() *DeckCreate {
	mutation := newDeckMutation(c.config, OpCreate)
	return &DeckCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Deck entities.
func (c *DeckClient) CreateBulk(builders ...*DeckCreate) *DeckCreateBulk {
	return &DeckCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeckClient) MapCreateBulk(slice any, setFunc func(*DeckCreate, int)) *DeckCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeckCreateBulk{err: fmt.Errorf("calling to DeckClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeckCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeckCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Deck.
func (c *DeckClient) Update() *DeckUpdate {
	mutation := newDeckMutation(c.config, OpUpdate)
	return &DeckUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeckClient) UpdateOne(_m *Deck) *DeckUpdateOne {
	mutation := newDeckMutation(c.config, OpUpdateOne, withDeck(_m))
	return &DeckUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeckClient) UpdateOneID(id int) *DeckUpdateOne {
	mutation := newDeckMutation(c.config, OpUpdateOne, withDeckID(id))
	return &DeckUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Deck.
func (c *DeckClient) Delete() *DeckDelete {
	mutation := newDeckMutation(c.config, OpDelete)
	return &DeckDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeckClient) DeleteOne(_m *Deck) *DeckDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeckClient) DeleteOneID(id int) *DeckDeleteOne {
	builder := c.Delete().Where(deck.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeckDeleteOne{builder}
}

// Query returns a query builder for Deck.
func (c *DeckClient) Query() *DeckQuery {
	return &DeckQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeck},
		inters: c.Interceptors(),
	}
}

// Get returns a Deck entity by its id.
func (c *DeckClient) Get(ctx context.Context, id int) (*Deck, error) {
	return c.Query().Where(deck.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeckClient) GetX(ctx context.Context, id int) *Deck {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Deck.
func (c *DeckClient) QueryUser(_m *Deck) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deck.Table, deck.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, deck.UserTable, deck.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWords queries the words edge of a Deck.
func (c *DeckClient) QueryWords(_m *Deck) *WordQuery {
	query := (&WordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deck.Table, deck.FieldID, id),
			sqlgraph.To(word.Table, word.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, deck.WordsTable, deck.WordsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeckClient) Hooks() []Hook {
	return c.hooks.Deck
}

// Interceptors returns the client interceptors.
func (c *DeckClient) Interceptors() []Interceptor {
	return c.inters.Deck
}

func (c *DeckClient) mutate(ctx context.Context, m *DeckMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeckCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeckUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeckUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeckDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Deck mutation op: %q", m.Op())
	}
}

// LearningStreakClient is a client for the LearningStreak schema.
type LearningStreakClient struct {
	config
}

// NewLearningStreakClient returns a client for the LearningStreak from the given config.
func NewLearningStreakClient(c config) *LearningStreakClient {
	return &LearningStreakClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `learningstreak.Hooks(f(g(h())))`.
func (c *LearningStreakClient) Use(hooks ...Hook) {
	c.hooks.LearningStreak = append(c.hooks.LearningStreak, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `learningstreak.Intercept(f(g(h())))`.
func (c *LearningStreakClient) Intercept(interceptors ...Interceptor) {
	c.inters.LearningStreak = append(c.inters.LearningStreak, interceptors...)
}

// Create returns a builder for creating a LearningStreak entity.
func (c *LearningStreakClient) Create() *LearningStreakCreate {
	mutation := newLearningStreakMutation(c.config, OpCreate)
	return &LearningStreakCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LearningStreak entities.
func (c *LearningStreakClient) CreateBulk(builders ...*LearningStreakCreate) *LearningStreakCreateBulk {
	return &LearningStreakCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LearningStreakClient) MapCreateBulk(slice any, setFunc func(*LearningStreakCreate, int)) *LearningStreakCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LearningStreakCreateBulk{err: fmt.Errorf("calling to LearningStreakClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LearningStreakCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LearningStreakCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LearningStreak.
func (c *LearningStreakClient) Update() *LearningStreakUpdate {
	mutation := newLearningStreakMutation(c.config, OpUpdate)
	return &LearningStreakUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LearningStreakClient) UpdateOne(_m *LearningStreak) *LearningStreakUpdateOne {
	mutation := newLearningStreakMutation(c.config, OpUpdateOne, withLearningStreak(_m))
	return &LearningStreakUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LearningStreakClient) UpdateOneID(id int) *LearningStreakUpdateOne {
	mutation := newLearningStreakMutation(c.config, OpUpdateOne, withLearningStreakID(id))
	return &LearningStreakUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LearningStreak.
func (c *LearningStreakClient) Delete() *LearningStreakDelete {
	mutation := newLearningStreakMutation(c.config, OpDelete)
	return &LearningStreakDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LearningStreakClient) DeleteOne(_m *LearningStreak) *LearningStreakDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LearningStreakClient) DeleteOneID(id int) *LearningStreakDeleteOne {
	builder := c.Delete().Where(learningstreak.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LearningStreakDeleteOne{builder}
}

// Query returns a query builder for LearningStreak.
func (c *LearningStreakClient) Query() *LearningStreakQuery {
	return &LearningStreakQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLearningStreak},
		inters: c.Interceptors(),
	}
}

// Get returns a LearningStreak entity by its id.
func (c *LearningStreakClient) Get(ctx context.Context, id int) (*LearningStreak, error) {
	return c.Query().Where(learningstreak.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LearningStreakClient) GetX(ctx context.Context, id int) *LearningStreak {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a LearningStreak.
func (c *LearningStreakClient) QueryUser(_m *LearningStreak) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(learningstreak.Table, learningstreak.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, learningstreak.UserTable, learningstreak.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LearningStreakClient) Hooks() []Hook {
	return c.hooks.LearningStreak
}

// Interceptors returns the client interceptors.
func (c *LearningStreakClient) Interceptors() []Interceptor {
	return c.inters.LearningStreak
}

func (c *LearningStreakClient) mutate(ctx context.Context, m *LearningStreakMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LearningStreakCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LearningStreakUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LearningStreakUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LearningStreakDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LearningStreak mutation op: %q", m.Op())
	}
}

// PronunciationAttemptClient is a client for the PronunciationAttempt schema.
type PronunciationAttemptClient struct {
	config
}

// NewPronunciationAttemptClient returns a client for the PronunciationAttempt from the given config.
func NewPronunciationAttemptClient(c config) *PronunciationAttemptClient {
	return &PronunciationAttemptClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pronunciationattempt.Hooks(f(g(h())))`.
func (c *PronunciationAttemptClient) Use(hooks ...Hook) {
	c.hooks.PronunciationAttempt = append(c.hooks.PronunciationAttempt, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pronunciationattempt.Intercept(f(g(h())))`.
func (c *PronunciationAttemptClient) Intercept(interceptors ...Interceptor) {
	c.inters.PronunciationAttempt = append(c.inters.PronunciationAttempt, interceptors...)
}

// Create returns a builder for creating a PronunciationAttempt entity.
func (c *PronunciationAttemptClient) Create() *PronunciationAttemptCreate {
	mutation := newPronunciationAttemptMutation(c.config, OpCreate)
	return &PronunciationAttemptCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PronunciationAttempt entities.
func (c *PronunciationAttemptClient) CreateBulk(builders ...*PronunciationAttemptCreate) *PronunciationAttemptCreateBulk {
	return &PronunciationAttemptCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PronunciationAttemptClient) MapCreateBulk(slice any, setFunc func(*PronunciationAttemptCreate, int)) *PronunciationAttemptCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PronunciationAttemptCreateBulk{err: fmt.Errorf("calling to PronunciationAttemptClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PronunciationAttemptCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PronunciationAttemptCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PronunciationAttempt.
func (c *PronunciationAttemptClient) Update() *PronunciationAttemptUpdate {
	mutation := newPronunciationAttemptMutation(c.config, OpUpdate)
	return &PronunciationAttemptUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PronunciationAttemptClient) UpdateOne(_m *PronunciationAttempt) *PronunciationAttemptUpdateOne {
	mutation := newPronunciationAttemptMutation(c.config, OpUpdateOne, withPronunciationAttempt(_m))
	return &PronunciationAttemptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PronunciationAttemptClient) UpdateOneID(id int) *PronunciationAttemptUpdateOne {
	mutation := newPronunciationAttemptMutation(c.config, OpUpdateOne, withPronunciationAttemptID(id))
	return &PronunciationAttemptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PronunciationAttempt.
func (c *PronunciationAttemptClient) Delete() *PronunciationAttemptDelete {
	mutation := newPronunciationAttemptMutation(c.config, OpDelete)
	return &PronunciationAttemptDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PronunciationAttemptClient) DeleteOne(_m *PronunciationAttempt) *PronunciationAttemptDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PronunciationAttemptClient) DeleteOneID(id int) *PronunciationAttemptDeleteOne {
	builder := c.Delete().Where(pronunciationattempt.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PronunciationAttemptDeleteOne{builder}
}

// Query returns a query builder for PronunciationAttempt.
func (c *PronunciationAttemptClient) Query() *PronunciationAttemptQuery {
	return &PronunciationAttemptQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePronunciationAttempt},
		inters: c.Interceptors(),
	}
}

// Get returns a PronunciationAttempt entity by its id.
func (c *PronunciationAttemptClient) Get(ctx context.Context, id int) (*PronunciationAttempt, error) {
	return c.Query().Where(pronunciationattempt.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PronunciationAttemptClient) GetX(ctx context.Context, id int) *PronunciationAttempt {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a PronunciationAttempt.
func (c *PronunciationAttemptClient) QueryUser(_m *PronunciationAttempt) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pronunciationattempt.Table, pronunciationattempt.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, pronunciationattempt.UserTable, pronunciationattempt.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestion queries the question edge of a PronunciationAttempt.
func (c *PronunciationAttemptClient) QueryQuestion(_m *PronunciationAttempt) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pronunciationattempt.Table, pronunciationattempt.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, pronunciationattempt.QuestionTable, pronunciationattempt.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWord queries the word edge of a PronunciationAttempt.
func (c *PronunciationAttemptClient) QueryWord(_m *PronunciationAttempt) *WordQuery {
	query := (&WordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pronunciationattempt.Table, pronunciationattempt.FieldID, id),
			sqlgraph.To(word.Table, word.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, pronunciationattempt.WordTable, pronunciationattempt.WordColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PronunciationAttemptClient) Hooks() []Hook {
	return c.hooks.PronunciationAttempt
}

// Interceptors returns the client interceptors.
func (c *PronunciationAttemptClient) Interceptors() []Interceptor {
	return c.inters.PronunciationAttempt
}

func (c *PronunciationAttemptClient) mutate(ctx context.Context, m *PronunciationAttemptMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PronunciationAttemptCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PronunciationAttemptUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PronunciationAttemptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PronunciationAttemptDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PronunciationAttempt mutation op: %q", m.Op())
	}
}

// QuestionClient is a client for the Question schema.
type QuestionClient struct {
	config
}

// NewQuestionClient returns a client for the Question from the given config.
func NewQuestionClient(c config) *QuestionClient {
	return &QuestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `question.Hooks(f(g(h())))`.
func (c *QuestionClient) Use(hooks ...Hook) {
	c.hooks.Question = append(c.hooks.Question, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `question.Intercept(f(g(h())))`.
func (c *QuestionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Question = append(c.inters.Question, interceptors...)
}

// Create returns a builder for creating a Question entity.
func (c *QuestionClient) Create() *QuestionCreate {
	mutation := newQuestionMutation(c.config, OpCreate)
	return &QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Question entities.
func (c *QuestionClient) CreateBulk(builders ...*QuestionCreate) *QuestionCreateBulk {
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *QuestionClient) MapCreateBulk(slice any, setFunc func(*QuestionCreate, int)) *QuestionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &QuestionCreateBulk{err: fmt.Errorf("calling to QuestionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*QuestionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Question.
func (c *QuestionClient) Update() *QuestionUpdate {
	mutation := newQuestionMutation(c.config, OpUpdate)
	return &QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionClient) UpdateOne(_m *Question) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestion(_m))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionClient) UpdateOneID(id int) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestionID(id))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Question.
func (c *QuestionClient) Delete() *QuestionDelete {
	mutation := newQuestionMutation(c.config, OpDelete)
	return &QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionClient) DeleteOne(_m *Question) *QuestionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *QuestionClient) DeleteOneID(id int) *QuestionDeleteOne {
	builder := c.Delete().Where(question.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionDeleteOne{builder}
}

// Query returns a query builder for Question.
func (c *QuestionClient) Query() *QuestionQuery {
	return &QuestionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeQuestion},
		inters: c.Interceptors(),
	}
}

// Get returns a Question entity by its id.
func (c *QuestionClient) Get(ctx context.Context, id int) (*Question, error) {
	return c.Query().Where(question.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionClient) GetX(ctx context.Context, id int) *Question {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWord queries the word edge of a Question.
func (c *QuestionClient) QueryWord(_m *Question) *WordQuery {
	query := (&WordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(word.Table, word.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, question.WordTable, question.WordColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestionReviews queries the question_reviews edge of a Question.
func (c *QuestionClient) QueryQuestionReviews(_m *Question) *QuestionReviewQuery {
	query := (&QuestionReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(questionreview.Table, questionreview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.QuestionReviewsTable, question.QuestionReviewsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestionAttempts queries the question_attempts edge of a Question.
func (c *QuestionClient) QueryQuestionAttempts(_m *Question) *QuestionAttemptQuery {
	query := (&QuestionAttemptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(questionattempt.Table, questionattempt.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.QuestionAttemptsTable, question.QuestionAttemptsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPronunciationAttempts queries the pronunciation_attempts edge of a Question.
func (c *QuestionClient) QueryPronunciationAttempts(_m *Question) *PronunciationAttemptQuery {
	query := (&PronunciationAttemptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(pronunciationattempt.Table, pronunciationattempt.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.PronunciationAttemptsTable, question.PronunciationAttemptsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionClient) Hooks() []Hook {
	return c.hooks.Question
}

// Interceptors returns the client interceptors.
func (c *QuestionClient) Interceptors() []Interceptor {
	return c.inters.Question
}

func (c *QuestionClient) mutate(ctx context.Context, m *QuestionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Question mutation op: %q", m.Op())
	}
}

// QuestionAttemptClient is a client for the QuestionAttempt schema.
type QuestionAttemptClient struct {
	config
}

// NewQuestionAttemptClient returns a client for the QuestionAttempt from the given config.
func NewQuestionAttemptClient(c config) *QuestionAttemptClient {
	return &QuestionAttemptClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `questionattempt.Hooks(f(g(h())))`.
func (c *QuestionAttemptClient) Use(hooks ...Hook) {
	c.hooks.QuestionAttempt = append(c.hooks.QuestionAttempt, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `questionattempt.Intercept(f(g(h())))`.
func (c *QuestionAttemptClient) Intercept(interceptors ...Interceptor) {
	c.inters.QuestionAttempt = append(c.inters.QuestionAttempt, interceptors...)
}

// Create returns a builder for creating a QuestionAttempt entity.
func (c *QuestionAttemptClient) Create() *QuestionAttemptCreate {
	mutation := newQuestionAttemptMutation(c.config, OpCreate)
	return &QuestionAttemptCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of QuestionAttempt entities.
func (c *QuestionAttemptClient) CreateBulk(builders ...*QuestionAttemptCreate) *QuestionAttemptCreateBulk {
	return &QuestionAttemptCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *QuestionAttemptClient) MapCreateBulk(slice any, setFunc func(*QuestionAttemptCreate, int)) *QuestionAttemptCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &QuestionAttemptCreateBulk{err: fmt.Errorf("calling to QuestionAttemptClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*QuestionAttemptCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &QuestionAttemptCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for QuestionAttempt.
func (c *QuestionAttemptClient) Update() *QuestionAttemptUpdate {
	mutation := newQuestionAttemptMutation(c.config, OpUpdate)
	return &QuestionAttemptUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionAttemptClient) UpdateOne(_m *QuestionAttempt) *QuestionAttemptUpdateOne {
	mutation := newQuestionAttemptMutation(c.config, OpUpdateOne, withQuestionAttempt(_m))
	return &QuestionAttemptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionAttemptClient) UpdateOneID(id int) *QuestionAttemptUpdateOne {
	mutation := newQuestionAttemptMutation(c.config, OpUpdateOne, withQuestionAttemptID(id))
	return &QuestionAttemptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for QuestionAttempt.
func (c *QuestionAttemptClient) Delete() *QuestionAttemptDelete {
	mutation := newQuestionAttemptMutation(c.config, OpDelete)
	return &QuestionAttemptDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionAttemptClient) DeleteOne(_m *QuestionAttempt) *QuestionAttemptDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *QuestionAttemptClient) DeleteOneID(id int) *QuestionAttemptDeleteOne {
	builder := c.Delete().Where(questionattempt.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionAttemptDeleteOne{builder}
}

// Query returns a query builder for QuestionAttempt.
func (c *QuestionAttemptClient) Query() *QuestionAttemptQuery {
	return &QuestionAttemptQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeQuestionAttempt},
		inters: c.Interceptors(),
	}
}

// Get returns a QuestionAttempt entity by its id.
func (c *QuestionAttemptClient) Get(ctx context.Context, id int) (*QuestionAttempt, error) {
	return c.Query().Where(questionattempt.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionAttemptClient) GetX(ctx context.Context, id int) *QuestionAttempt {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a QuestionAttempt.
func (c *QuestionAttemptClient) QueryUser(_m *QuestionAttempt) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questionattempt.Table, questionattempt.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, questionattempt.UserTable, questionattempt.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestion queries the question edge of a QuestionAttempt.
func (c *QuestionAttemptClient) QueryQuestion(_m *QuestionAttempt) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questionattempt.Table, questionattempt.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, questionattempt.QuestionTable, questionattempt.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestionReview queries the question_review edge of a QuestionAttempt.
func (c *QuestionAttemptClient) QueryQuestionReview(_m *QuestionAttempt) *QuestionReviewQuery {
	query := (&QuestionReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questionattempt.Table, questionattempt.FieldID, id),
			sqlgraph.To(questionreview.Table, questionreview.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, questionattempt.QuestionReviewTable, questionattempt.QuestionReviewColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionAttemptClient) Hooks() []Hook {
	return c.hooks.QuestionAttempt
}

// Interceptors returns the client interceptors.
func (c *QuestionAttemptClient) Interceptors() []Interceptor {
	return c.inters.QuestionAttempt
}

func (c *QuestionAttemptClient) mutate(ctx context.Context, m *QuestionAttemptMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&QuestionAttemptCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&QuestionAttemptUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&QuestionAttemptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&QuestionAttemptDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown QuestionAttempt mutation op: %q", m.Op())
	}
}

// QuestionReviewClient is a client for the QuestionReview schema.
type QuestionReviewClient struct {
	config
}

// NewQuestionReviewClient returns a client for the QuestionReview from the given config.
func NewQuestionReviewClient(c config) *QuestionReviewClient {
	return &QuestionReviewClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `questionreview.Hooks(f(g(h())))`.
func (c *QuestionReviewClient) Use(hooks ...Hook) {
	c.hooks.QuestionReview = append(c.hooks.QuestionReview, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `questionreview.Intercept(f(g(h())))`.
func (c *QuestionReviewClient) Intercept(interceptors ...Interceptor) {
	c.inters.QuestionReview = append(c.inters.QuestionReview, interceptors...)
}

// Create returns a builder for creating a QuestionReview entity.
func (c *QuestionReviewClient) Create() *QuestionReviewCreate {
	mutation := newQuestionReviewMutation(c.config, OpCreate)
	return &QuestionReviewCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of QuestionReview entities.
func (c *QuestionReviewClient) CreateBulk(builders ...*QuestionReviewCreate) *QuestionReviewCreateBulk {
	return &QuestionReviewCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *QuestionReviewClient) MapCreateBulk(slice any, setFunc func(*QuestionReviewCreate, int)) *QuestionReviewCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &QuestionReviewCreateBulk{err: fmt.Errorf("calling to QuestionReviewClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*QuestionReviewCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &QuestionReviewCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for QuestionReview.
func (c *QuestionReviewClient) Update() *QuestionReviewUpdate {
	mutation := newQuestionReviewMutation(c.config, OpUpdate)
	return &QuestionReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionReviewClient) UpdateOne(_m *QuestionReview) *QuestionReviewUpdateOne {
	mutation := newQuestionReviewMutation(c.config, OpUpdateOne, withQuestionReview(_m))
	return &QuestionReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionReviewClient) UpdateOneID(id int) *QuestionReviewUpdateOne {
	mutation := newQuestionReviewMutation(c.config, OpUpdateOne, withQuestionReviewID(id))
	return &QuestionReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for QuestionReview.
func (c *QuestionReviewClient) Delete() *QuestionReviewDelete {
	mutation := newQuestionReviewMutation(c.config, OpDelete)
	return &QuestionReviewDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionReviewClient) DeleteOne(_m *QuestionReview) *QuestionReviewDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *QuestionReviewClient) DeleteOneID(id int) *QuestionReviewDeleteOne {
	builder := c.Delete().Where(questionreview.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionReviewDeleteOne{builder}
}

// Query returns a query builder for QuestionReview.
func (c *QuestionReviewClient) Query() *QuestionReviewQuery {
	return &QuestionReviewQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeQuestionReview},
		inters: c.Interceptors(),
	}
}

// Get returns a QuestionReview entity by its id.
func (c *QuestionReviewClient) Get(ctx context.Context, id int) (*QuestionReview, error) {
	return c.Query().Where(questionreview.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionReviewClient) GetX(ctx context.Context, id int) *QuestionReview {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a QuestionReview.
func (c *QuestionReviewClient) QueryUser(_m *QuestionReview) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questionreview.Table, questionreview.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, questionreview.UserTable, questionreview.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestion queries the question edge of a QuestionReview.
func (c *QuestionReviewClient) QueryQuestion(_m *QuestionReview) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questionreview.Table, questionreview.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, questionreview.QuestionTable, questionreview.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestionAttempts queries the question_attempts edge of a QuestionReview.
func (c *QuestionReviewClient) QueryQuestionAttempts(_m *QuestionReview) *QuestionAttemptQuery {
	query := (&QuestionAttemptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questionreview.Table, questionreview.FieldID, id),
			sqlgraph.To(questionattempt.Table, questionattempt.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, questionreview.QuestionAttemptsTable, questionreview.QuestionAttemptsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionReviewClient) Hooks() []Hook {
	return c.hooks.QuestionReview
}

// Interceptors returns the client interceptors.
func (c *QuestionReviewClient) Interceptors() []Interceptor {
	return c.inters.QuestionReview
}

func (c *QuestionReviewClient) mutate(ctx context.Context, m *QuestionReviewMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&QuestionReviewCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&QuestionReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&QuestionReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&QuestionReviewDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown QuestionReview mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDecks queries the decks edge of a User.
func (c *UserClient) QueryDecks(_m *User) *DeckQuery {
	query := (&DeckClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(deck.Table, deck.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.DecksTable, user.DecksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestionReviews queries the question_reviews edge of a User.
func (c *UserClient) QueryQuestionReviews(_m *User) *QuestionReviewQuery {
	query := (&QuestionReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(questionreview.Table, questionreview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.QuestionReviewsTable, user.QuestionReviewsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestionAttempts queries the question_attempts edge of a User.
func (c *UserClient) QueryQuestionAttempts(_m *User) *QuestionAttemptQuery {
	query := (&QuestionAttemptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(questionattempt.Table, questionattempt.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.QuestionAttemptsTable, user.QuestionAttemptsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPronunciationAttempts queries the pronunciation_attempts edge of a User.
func (c *UserClient) QueryPronunciationAttempts(_m *User) *PronunciationAttemptQuery {
	query := (&PronunciationAttemptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(pronunciationattempt.Table, pronunciationattempt.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PronunciationAttemptsTable, user.PronunciationAttemptsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserStats queries the user_stats edge of a User.
func (c *UserClient) QueryUserStats(_m *User) *UserStatsQuery {
	query := (&UserStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userstats.Table, userstats.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserStatsTable, user.UserStatsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLearningStreaks queries the learning_streaks edge of a User.
func (c *UserClient) QueryLearningStreaks(_m *User) *LearningStreakQuery {
	query := (&LearningStreakClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(learningstreak.Table, learningstreak.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LearningStreaksTable, user.LearningStreaksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserStatsClient is a client for the UserStats schema.
type UserStatsClient struct {
	config
}

// NewUserStatsClient returns a client for the UserStats from the given config.
func NewUserStatsClient(c config) *UserStatsClient {
	return &UserStatsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userstats.Hooks(f(g(h())))`.
func (c *UserStatsClient) Use(hooks ...Hook) {
	c.hooks.UserStats = append(c.hooks.UserStats, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userstats.Intercept(f(g(h())))`.
func (c *UserStatsClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserStats = append(c.inters.UserStats, interceptors...)
}

// Create returns a builder for creating a UserStats entity.
func (c *UserStatsClient) Create() *UserStatsCreate {
	mutation := newUserStatsMutation(c.config, OpCreate)
	return &UserStatsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserStats entities.
func (c *UserStatsClient) CreateBulk(builders ...*UserStatsCreate) *UserStatsCreateBulk {
	return &UserStatsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserStatsClient) MapCreateBulk(slice any, setFunc func(*UserStatsCreate, int)) *UserStatsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserStatsCreateBulk{err: fmt.Errorf("calling to UserStatsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserStatsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserStatsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserStats.
func (c *UserStatsClient) Update() *UserStatsUpdate {
	mutation := newUserStatsMutation(c.config, OpUpdate)
	return &UserStatsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserStatsClient) UpdateOne(_m *UserStats) *UserStatsUpdateOne {
	mutation := newUserStatsMutation(c.config, OpUpdateOne, withUserStats(_m))
	return &UserStatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserStatsClient) UpdateOneID(id int) *UserStatsUpdateOne {
	mutation := newUserStatsMutation(c.config, OpUpdateOne, withUserStatsID(id))
	return &UserStatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserStats.
func (c *UserStatsClient) Delete() *UserStatsDelete {
	mutation := newUserStatsMutation(c.config, OpDelete)
	return &UserStatsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserStatsClient) DeleteOne(_m *UserStats) *UserStatsDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserStatsClient) DeleteOneID(id int) *UserStatsDeleteOne {
	builder := c.Delete().Where(userstats.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserStatsDeleteOne{builder}
}

// Query returns a query builder for UserStats.
func (c *UserStatsClient) Query() *UserStatsQuery {
	return &UserStatsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserStats},
		inters: c.Interceptors(),
	}
}

// Get returns a UserStats entity by its id.
func (c *UserStatsClient) Get(ctx context.Context, id int) (*UserStats, error) {
	return c.Query().Where(userstats.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserStatsClient) GetX(ctx context.Context, id int) *UserStats {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserStats.
func (c *UserStatsClient) QueryUser(_m *UserStats) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userstats.Table, userstats.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userstats.UserTable, userstats.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserStatsClient) Hooks() []Hook {
	return c.hooks.UserStats
}

// Interceptors returns the client interceptors.
func (c *UserStatsClient) Interceptors() []Interceptor {
	return c.inters.UserStats
}

func (c *UserStatsClient) mutate(ctx context.Context, m *UserStatsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserStatsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserStatsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserStatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserStatsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserStats mutation op: %q", m.Op())
	}
}

// WordClient is a client for the Word schema.
type WordClient struct {
	config
}

// NewWordClient returns a client for the Word from the given config.
func NewWordClient(c config) *WordClient {
	return &WordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `word.Hooks(f(g(h())))`.
func (c *WordClient) Use(hooks ...Hook) {
	c.hooks.Word = append(c.hooks.Word, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `word.Intercept(f(g(h())))`.
func (c *WordClient) Intercept(interceptors ...Interceptor) {
	c.inters.Word = append(c.inters.Word, interceptors...)
}

// Create returns a builder for creating a Word entity.
func (c *WordClient) Create() *WordCreate {
	mutation := newWordMutation(c.config, OpCreate)
	return &WordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Word entities.
func (c *WordClient) CreateBulk(builders ...*WordCreate) *WordCreateBulk {
	return &WordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WordClient) MapCreateBulk(slice any, setFunc func(*WordCreate, int)) *WordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WordCreateBulk{err: fmt.Errorf("calling to WordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Word.
func (c *WordClient) Update() *WordUpdate {
	mutation := newWordMutation(c.config, OpUpdate)
	return &WordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WordClient) UpdateOne(_m *Word) *WordUpdateOne {
	mutation := newWordMutation(c.config, OpUpdateOne, withWord(_m))
	return &WordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WordClient) UpdateOneID(id int) *WordUpdateOne {
	mutation := newWordMutation(c.config, OpUpdateOne, withWordID(id))
	return &WordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Word.
func (c *WordClient) Delete() *WordDelete {
	mutation := newWordMutation(c.config, OpDelete)
	return &WordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WordClient) DeleteOne(_m *Word) *WordDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WordClient) DeleteOneID(id int) *WordDeleteOne {
	builder := c.Delete().Where(word.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WordDeleteOne{builder}
}

// Query returns a query builder for Word.
func (c *WordClient) Query() *WordQuery {
	return &WordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWord},
		inters: c.Interceptors(),
	}
}

// Get returns a Word entity by its id.
func (c *WordClient) Get(ctx context.Context, id int) (*Word, error) {
	return c.Query().Where(word.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WordClient) GetX(ctx context.Context, id int) *Word {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDeck queries the deck edge of a Word.
func (c *WordClient) QueryDeck(_m *Word) *DeckQuery {
	query := (&DeckClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(word.Table, word.FieldID, id),
			sqlgraph.To(deck.Table, deck.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, word.DeckTable, word.DeckColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestions queries the questions edge of a Word.
func (c *WordClient) QueryQuestions(_m *Word) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(word.Table, word.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, word.QuestionsTable, word.QuestionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPronunciationAttempts queries the pronunciation_attempts edge of a Word.
func (c *WordClient) QueryPronunciationAttempts(_m *Word) *PronunciationAttemptQuery {
	query := (&PronunciationAttemptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(word.Table, word.FieldID, id),
			sqlgraph.To(pronunciationattempt.Table, pronunciationattempt.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, word.PronunciationAttemptsTable, word.PronunciationAttemptsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WordClient) Hooks() []Hook {
	return c.hooks.Word
}

// Interceptors returns the client interceptors.
func (c *WordClient) Interceptors() []Interceptor {
	return c.inters.Word
}

func (c *WordClient) mutate(ctx context.Context, m *WordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Word mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Deck, LearningStreak, PronunciationAttempt, Question, QuestionAttempt,
		QuestionReview, User, UserStats, Word []ent.Hook
	}
	inters struct {
		Deck, LearningStreak, PronunciationAttempt, Question, QuestionAttempt,
		QuestionReview, User, UserStats, Word []ent.Interceptor
	}
)
