// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"learning-french-service/internal/ent/deck"
	"learning-french-service/internal/ent/learningstreak"
	"learning-french-service/internal/ent/predicate"
	"learning-french-service/internal/ent/pronunciationattempt"
	"learning-french-service/internal/ent/question"
	"learning-french-service/internal/ent/questionattempt"
	"learning-french-service/internal/ent/questionreview"
	"learning-french-service/internal/ent/user"
	"learning-french-service/internal/ent/userstats"
	"learning-french-service/internal/ent/word"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDeck                 = "Deck"
	TypeLearningStreak       = "LearningStreak"
	TypePronunciationAttempt = "PronunciationAttempt"
	TypeQuestion             = "Question"
	TypeQuestionAttempt      = "QuestionAttempt"
	TypeQuestionReview       = "QuestionReview"
	TypeUser                 = "User"
	TypeUserStats            = "UserStats"
	TypeWord                 = "Word"
)

// DeckMutation represents an operation that mutates the Deck nodes in the graph.
type DeckMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	category      *string
	target_level  *string
	is_active     *bool
	word_count    *int
	addword_count *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	words         map[int]struct{}
	removedwords  map[int]struct{}
	clearedwords  bool
	done          bool
	oldValue      func(context.Context) (*Deck, error)
	predicates    []predicate.Deck
}

var _ ent.Mutation = (*DeckMutation)(nil)

// deckOption allows management of the mutation configuration using functional options.
type deckOption func(*DeckMutation)

// newDeckMutation creates new mutation for the Deck entity.
func newDeckMutation(c config, op Op, opts ...deckOption) *DeckMutation {
	m := &DeckMutation{
		config:        c,
		op:            op,
		typ:           TypeDeck,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeckID sets the ID field of the mutation.
func withDeckID(id int) deckOption {
	return func(m *DeckMutation) {
		var (
			err   error
			once  sync.Once
			value *Deck
		)
		m.oldValue = func(ctx context.Context) (*Deck, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Deck.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeck sets the old Deck of the mutation.
func withDeck(node *Deck) deckOption {
	return func(m *DeckMutation) {
		m.oldValue = func(context.Context) (*Deck, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeckMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeckMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeckMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeckMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Deck.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DeckMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeckMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeckMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DeckMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DeckMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DeckMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[deck.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DeckMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[deck.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DeckMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, deck.FieldDescription)
}

// SetCategory sets the "category" field.
func (m *DeckMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *DeckMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *DeckMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[deck.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *DeckMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[deck.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *DeckMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, deck.FieldCategory)
}

// SetTargetLevel sets the "target_level" field.
func (m *DeckMutation) SetTargetLevel(s string) {
	m.target_level = &s
}

// TargetLevel returns the value of the "target_level" field in the mutation.
func (m *DeckMutation) TargetLevel() (r string, exists bool) {
	v := m.target_level
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetLevel returns the old "target_level" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldTargetLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetLevel: %w", err)
	}
	return oldValue.TargetLevel, nil
}

// ClearTargetLevel clears the value of the "target_level" field.
func (m *DeckMutation) ClearTargetLevel() {
	m.target_level = nil
	m.clearedFields[deck.FieldTargetLevel] = struct{}{}
}

// TargetLevelCleared returns if the "target_level" field was cleared in this mutation.
func (m *DeckMutation) TargetLevelCleared() bool {
	_, ok := m.clearedFields[deck.FieldTargetLevel]
	return ok
}

// ResetTargetLevel resets all changes to the "target_level" field.
func (m *DeckMutation) ResetTargetLevel() {
	m.target_level = nil
	delete(m.clearedFields, deck.FieldTargetLevel)
}

// SetIsActive sets the "is_active" field.
func (m *DeckMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *DeckMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *DeckMutation) ResetIsActive() {
	m.is_active = nil
}

// SetWordCount sets the "word_count" field.
func (m *DeckMutation) SetWordCount(i int) {
	m.word_count = &i
	m.addword_count = nil
}

// WordCount returns the value of the "word_count" field in the mutation.
func (m *DeckMutation) WordCount() (r int, exists bool) {
	v := m.word_count
	if v == nil {
		return
	}
	return *v, true
}

// OldWordCount returns the old "word_count" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldWordCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWordCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWordCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWordCount: %w", err)
	}
	return oldValue.WordCount, nil
}

// AddWordCount adds i to the "word_count" field.
func (m *DeckMutation) AddWordCount(i int) {
	if m.addword_count != nil {
		*m.addword_count += i
	} else {
		m.addword_count = &i
	}
}

// AddedWordCount returns the value that was added to the "word_count" field in this mutation.
func (m *DeckMutation) AddedWordCount() (r int, exists bool) {
	v := m.addword_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetWordCount resets all changes to the "word_count" field.
func (m *DeckMutation) ResetWordCount() {
	m.word_count = nil
	m.addword_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeckMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeckMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeckMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeckMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeckMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeckMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *DeckMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *DeckMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DeckMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *DeckMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DeckMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DeckMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddWordIDs adds the "words" edge to the Word entity by ids.
func (m *DeckMutation) AddWordIDs(ids ...int) {
	if m.words == nil {
		m.words = make(map[int]struct{})
	}
	for i := range ids {
		m.words[ids[i]] = struct{}{}
	}
}

// ClearWords clears the "words" edge to the Word entity.
func (m *DeckMutation) ClearWords() {
	m.clearedwords = true
}

// WordsCleared reports if the "words" edge to the Word entity was cleared.
func (m *DeckMutation) WordsCleared() bool {
	return m.clearedwords
}

// RemoveWordIDs removes the "words" edge to the Word entity by IDs.
func (m *DeckMutation) RemoveWordIDs(ids ...int) {
	if m.removedwords == nil {
		m.removedwords = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.words, ids[i])
		m.removedwords[ids[i]] = struct{}{}
	}
}

// RemovedWords returns the removed IDs of the "words" edge to the Word entity.
func (m *DeckMutation) RemovedWordsIDs() (ids []int) {
	for id := range m.removedwords {
		ids = append(ids, id)
	}
	return
}

// WordsIDs returns the "words" edge IDs in the mutation.
func (m *DeckMutation) WordsIDs() (ids []int) {
	for id := range m.words {
		ids = append(ids, id)
	}
	return
}

// ResetWords resets all changes to the "words" edge.
func (m *DeckMutation) ResetWords() {
	m.words = nil
	m.clearedwords = false
	m.removedwords = nil
}

// Where appends a list predicates to the DeckMutation builder.
func (m *DeckMutation) Where(ps ...predicate.Deck) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeckMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeckMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Deck, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeckMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeckMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Deck).
func (m *DeckMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeckMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, deck.FieldName)
	}
	if m.description != nil {
		fields = append(fields, deck.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, deck.FieldCategory)
	}
	if m.target_level != nil {
		fields = append(fields, deck.FieldTargetLevel)
	}
	if m.is_active != nil {
		fields = append(fields, deck.FieldIsActive)
	}
	if m.word_count != nil {
		fields = append(fields, deck.FieldWordCount)
	}
	if m.created_at != nil {
		fields = append(fields, deck.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deck.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeckMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deck.FieldName:
		return m.Name()
	case deck.FieldDescription:
		return m.Description()
	case deck.FieldCategory:
		return m.Category()
	case deck.FieldTargetLevel:
		return m.TargetLevel()
	case deck.FieldIsActive:
		return m.IsActive()
	case deck.FieldWordCount:
		return m.WordCount()
	case deck.FieldCreatedAt:
		return m.CreatedAt()
	case deck.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeckMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deck.FieldName:
		return m.OldName(ctx)
	case deck.FieldDescription:
		return m.OldDescription(ctx)
	case deck.FieldCategory:
		return m.OldCategory(ctx)
	case deck.FieldTargetLevel:
		return m.OldTargetLevel(ctx)
	case deck.FieldIsActive:
		return m.OldIsActive(ctx)
	case deck.FieldWordCount:
		return m.OldWordCount(ctx)
	case deck.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deck.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Deck field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeckMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deck.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case deck.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case deck.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case deck.FieldTargetLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetLevel(v)
		return nil
	case deck.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case deck.FieldWordCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWordCount(v)
		return nil
	case deck.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deck.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Deck field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeckMutation) AddedFields() []string {
	var fields []string
	if m.addword_count != nil {
		fields = append(fields, deck.FieldWordCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeckMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deck.FieldWordCount:
		return m.AddedWordCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeckMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deck.FieldWordCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWordCount(v)
		return nil
	}
	return fmt.Errorf("unknown Deck numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeckMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deck.FieldDescription) {
		fields = append(fields, deck.FieldDescription)
	}
	if m.FieldCleared(deck.FieldCategory) {
		fields = append(fields, deck.FieldCategory)
	}
	if m.FieldCleared(deck.FieldTargetLevel) {
		fields = append(fields, deck.FieldTargetLevel)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeckMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeckMutation) ClearField(name string) error {
	switch name {
	case deck.FieldDescription:
		m.ClearDescription()
		return nil
	case deck.FieldCategory:
		m.ClearCategory()
		return nil
	case deck.FieldTargetLevel:
		m.ClearTargetLevel()
		return nil
	}
	return fmt.Errorf("unknown Deck nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeckMutation) ResetField(name string) error {
	switch name {
	case deck.FieldName:
		m.ResetName()
		return nil
	case deck.FieldDescription:
		m.ResetDescription()
		return nil
	case deck.FieldCategory:
		m.ResetCategory()
		return nil
	case deck.FieldTargetLevel:
		m.ResetTargetLevel()
		return nil
	case deck.FieldIsActive:
		m.ResetIsActive()
		return nil
	case deck.FieldWordCount:
		m.ResetWordCount()
		return nil
	case deck.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deck.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Deck field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeckMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, deck.EdgeUser)
	}
	if m.words != nil {
		edges = append(edges, deck.EdgeWords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeckMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deck.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case deck.EdgeWords:
		ids := make([]ent.Value, 0, len(m.words))
		for id := range m.words {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeckMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedwords != nil {
		edges = append(edges, deck.EdgeWords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeckMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deck.EdgeWords:
		ids := make([]ent.Value, 0, len(m.removedwords))
		for id := range m.removedwords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeckMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, deck.EdgeUser)
	}
	if m.clearedwords {
		edges = append(edges, deck.EdgeWords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeckMutation) EdgeCleared(name string) bool {
	switch name {
	case deck.EdgeUser:
		return m.cleareduser
	case deck.EdgeWords:
		return m.clearedwords
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeckMutation) ClearEdge(name string) error {
	switch name {
	case deck.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Deck unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeckMutation) ResetEdge(name string) error {
	switch name {
	case deck.EdgeUser:
		m.ResetUser()
		return nil
	case deck.EdgeWords:
		m.ResetWords()
		return nil
	}
	return fmt.Errorf("unknown Deck edge %s", name)
}

// LearningStreakMutation represents an operation that mutates the LearningStreak nodes in the graph.
type LearningStreakMutation struct {
	config
	op               Op
	typ              string
	id               *int
	start_date       *time.Time
	end_date         *time.Time
	streak_length    *int
	addstreak_length *int
	is_current       *bool
	created_at       *time.Time
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*LearningStreak, error)
	predicates       []predicate.LearningStreak
}

var _ ent.Mutation = (*LearningStreakMutation)(nil)

// learningstreakOption allows management of the mutation configuration using functional options.
type learningstreakOption func(*LearningStreakMutation)

// newLearningStreakMutation creates new mutation for the LearningStreak entity.
func newLearningStreakMutation(c config, op Op, opts ...learningstreakOption) *LearningStreakMutation {
	m := &LearningStreakMutation{
		config:        c,
		op:            op,
		typ:           TypeLearningStreak,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLearningStreakID sets the ID field of the mutation.
func withLearningStreakID(id int) learningstreakOption {
	return func(m *LearningStreakMutation) {
		var (
			err   error
			once  sync.Once
			value *LearningStreak
		)
		m.oldValue = func(ctx context.Context) (*LearningStreak, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LearningStreak.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLearningStreak sets the old LearningStreak of the mutation.
func withLearningStreak(node *LearningStreak) learningstreakOption {
	return func(m *LearningStreakMutation) {
		m.oldValue = func(context.Context) (*LearningStreak, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LearningStreakMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LearningStreakMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LearningStreakMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LearningStreakMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LearningStreak.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartDate sets the "start_date" field.
func (m *LearningStreakMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *LearningStreakMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the LearningStreak entity.
// If the LearningStreak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearningStreakMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *LearningStreakMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *LearningStreakMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *LearningStreakMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the LearningStreak entity.
// If the LearningStreak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearningStreakMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *LearningStreakMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[learningstreak.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *LearningStreakMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[learningstreak.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *LearningStreakMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, learningstreak.FieldEndDate)
}

// SetStreakLength sets the "streak_length" field.
func (m *LearningStreakMutation) SetStreakLength(i int) {
	m.streak_length = &i
	m.addstreak_length = nil
}

// StreakLength returns the value of the "streak_length" field in the mutation.
func (m *LearningStreakMutation) StreakLength() (r int, exists bool) {
	v := m.streak_length
	if v == nil {
		return
	}
	return *v, true
}

// OldStreakLength returns the old "streak_length" field's value of the LearningStreak entity.
// If the LearningStreak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearningStreakMutation) OldStreakLength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreakLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreakLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreakLength: %w", err)
	}
	return oldValue.StreakLength, nil
}

// AddStreakLength adds i to the "streak_length" field.
func (m *LearningStreakMutation) AddStreakLength(i int) {
	if m.addstreak_length != nil {
		*m.addstreak_length += i
	} else {
		m.addstreak_length = &i
	}
}

// AddedStreakLength returns the value that was added to the "streak_length" field in this mutation.
func (m *LearningStreakMutation) AddedStreakLength() (r int, exists bool) {
	v := m.addstreak_length
	if v == nil {
		return
	}
	return *v, true
}

// ResetStreakLength resets all changes to the "streak_length" field.
func (m *LearningStreakMutation) ResetStreakLength() {
	m.streak_length = nil
	m.addstreak_length = nil
}

// SetIsCurrent sets the "is_current" field.
func (m *LearningStreakMutation) SetIsCurrent(b bool) {
	m.is_current = &b
}

// IsCurrent returns the value of the "is_current" field in the mutation.
func (m *LearningStreakMutation) IsCurrent() (r bool, exists bool) {
	v := m.is_current
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCurrent returns the old "is_current" field's value of the LearningStreak entity.
// If the LearningStreak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearningStreakMutation) OldIsCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCurrent: %w", err)
	}
	return oldValue.IsCurrent, nil
}

// ResetIsCurrent resets all changes to the "is_current" field.
func (m *LearningStreakMutation) ResetIsCurrent() {
	m.is_current = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LearningStreakMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LearningStreakMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LearningStreak entity.
// If the LearningStreak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearningStreakMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LearningStreakMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *LearningStreakMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *LearningStreakMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LearningStreakMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *LearningStreakMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LearningStreakMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LearningStreakMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the LearningStreakMutation builder.
func (m *LearningStreakMutation) Where(ps ...predicate.LearningStreak) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LearningStreakMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LearningStreakMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LearningStreak, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LearningStreakMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LearningStreakMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LearningStreak).
func (m *LearningStreakMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LearningStreakMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.start_date != nil {
		fields = append(fields, learningstreak.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, learningstreak.FieldEndDate)
	}
	if m.streak_length != nil {
		fields = append(fields, learningstreak.FieldStreakLength)
	}
	if m.is_current != nil {
		fields = append(fields, learningstreak.FieldIsCurrent)
	}
	if m.created_at != nil {
		fields = append(fields, learningstreak.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LearningStreakMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case learningstreak.FieldStartDate:
		return m.StartDate()
	case learningstreak.FieldEndDate:
		return m.EndDate()
	case learningstreak.FieldStreakLength:
		return m.StreakLength()
	case learningstreak.FieldIsCurrent:
		return m.IsCurrent()
	case learningstreak.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LearningStreakMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case learningstreak.FieldStartDate:
		return m.OldStartDate(ctx)
	case learningstreak.FieldEndDate:
		return m.OldEndDate(ctx)
	case learningstreak.FieldStreakLength:
		return m.OldStreakLength(ctx)
	case learningstreak.FieldIsCurrent:
		return m.OldIsCurrent(ctx)
	case learningstreak.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LearningStreak field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LearningStreakMutation) SetField(name string, value ent.Value) error {
	switch name {
	case learningstreak.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case learningstreak.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case learningstreak.FieldStreakLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreakLength(v)
		return nil
	case learningstreak.FieldIsCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCurrent(v)
		return nil
	case learningstreak.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LearningStreak field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LearningStreakMutation) AddedFields() []string {
	var fields []string
	if m.addstreak_length != nil {
		fields = append(fields, learningstreak.FieldStreakLength)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LearningStreakMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case learningstreak.FieldStreakLength:
		return m.AddedStreakLength()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LearningStreakMutation) AddField(name string, value ent.Value) error {
	switch name {
	case learningstreak.FieldStreakLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStreakLength(v)
		return nil
	}
	return fmt.Errorf("unknown LearningStreak numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LearningStreakMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(learningstreak.FieldEndDate) {
		fields = append(fields, learningstreak.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LearningStreakMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LearningStreakMutation) ClearField(name string) error {
	switch name {
	case learningstreak.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown LearningStreak nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LearningStreakMutation) ResetField(name string) error {
	switch name {
	case learningstreak.FieldStartDate:
		m.ResetStartDate()
		return nil
	case learningstreak.FieldEndDate:
		m.ResetEndDate()
		return nil
	case learningstreak.FieldStreakLength:
		m.ResetStreakLength()
		return nil
	case learningstreak.FieldIsCurrent:
		m.ResetIsCurrent()
		return nil
	case learningstreak.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown LearningStreak field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LearningStreakMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, learningstreak.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LearningStreakMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case learningstreak.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LearningStreakMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LearningStreakMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LearningStreakMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, learningstreak.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LearningStreakMutation) EdgeCleared(name string) bool {
	switch name {
	case learningstreak.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LearningStreakMutation) ClearEdge(name string) error {
	switch name {
	case learningstreak.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown LearningStreak unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LearningStreakMutation) ResetEdge(name string) error {
	switch name {
	case learningstreak.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown LearningStreak edge %s", name)
}

// PronunciationAttemptMutation represents an operation that mutates the PronunciationAttempt nodes in the graph.
type PronunciationAttemptMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	user_audio_url         *string
	reference_audio_url    *string
	similarity_score       *float64
	addsimilarity_score    *float64
	pronunciation_feedback *string
	phonetic_accuracy      *map[string]interface{}
	attempt_date           *time.Time
	was_successful         *bool
	clearedFields          map[string]struct{}
	user                   *int
	cleareduser            bool
	question               *int
	clearedquestion        bool
	word                   *int
	clearedword            bool
	done                   bool
	oldValue               func(context.Context) (*PronunciationAttempt, error)
	predicates             []predicate.PronunciationAttempt
}

var _ ent.Mutation = (*PronunciationAttemptMutation)(nil)

// pronunciationattemptOption allows management of the mutation configuration using functional options.
type pronunciationattemptOption func(*PronunciationAttemptMutation)

// newPronunciationAttemptMutation creates new mutation for the PronunciationAttempt entity.
func newPronunciationAttemptMutation(c config, op Op, opts ...pronunciationattemptOption) *PronunciationAttemptMutation {
	m := &PronunciationAttemptMutation{
		config:        c,
		op:            op,
		typ:           TypePronunciationAttempt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPronunciationAttemptID sets the ID field of the mutation.
func withPronunciationAttemptID(id int) pronunciationattemptOption {
	return func(m *PronunciationAttemptMutation) {
		var (
			err   error
			once  sync.Once
			value *PronunciationAttempt
		)
		m.oldValue = func(ctx context.Context) (*PronunciationAttempt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PronunciationAttempt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPronunciationAttempt sets the old PronunciationAttempt of the mutation.
func withPronunciationAttempt(node *PronunciationAttempt) pronunciationattemptOption {
	return func(m *PronunciationAttemptMutation) {
		m.oldValue = func(context.Context) (*PronunciationAttempt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PronunciationAttemptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PronunciationAttemptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PronunciationAttemptMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PronunciationAttemptMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PronunciationAttempt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserAudioURL sets the "user_audio_url" field.
func (m *PronunciationAttemptMutation) SetUserAudioURL(s string) {
	m.user_audio_url = &s
}

// UserAudioURL returns the value of the "user_audio_url" field in the mutation.
func (m *PronunciationAttemptMutation) UserAudioURL() (r string, exists bool) {
	v := m.user_audio_url
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAudioURL returns the old "user_audio_url" field's value of the PronunciationAttempt entity.
// If the PronunciationAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PronunciationAttemptMutation) OldUserAudioURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAudioURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAudioURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAudioURL: %w", err)
	}
	return oldValue.UserAudioURL, nil
}

// ResetUserAudioURL resets all changes to the "user_audio_url" field.
func (m *PronunciationAttemptMutation) ResetUserAudioURL() {
	m.user_audio_url = nil
}

// SetReferenceAudioURL sets the "reference_audio_url" field.
func (m *PronunciationAttemptMutation) SetReferenceAudioURL(s string) {
	m.reference_audio_url = &s
}

// ReferenceAudioURL returns the value of the "reference_audio_url" field in the mutation.
func (m *PronunciationAttemptMutation) ReferenceAudioURL() (r string, exists bool) {
	v := m.reference_audio_url
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceAudioURL returns the old "reference_audio_url" field's value of the PronunciationAttempt entity.
// If the PronunciationAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PronunciationAttemptMutation) OldReferenceAudioURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceAudioURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceAudioURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceAudioURL: %w", err)
	}
	return oldValue.ReferenceAudioURL, nil
}

// ClearReferenceAudioURL clears the value of the "reference_audio_url" field.
func (m *PronunciationAttemptMutation) ClearReferenceAudioURL() {
	m.reference_audio_url = nil
	m.clearedFields[pronunciationattempt.FieldReferenceAudioURL] = struct{}{}
}

// ReferenceAudioURLCleared returns if the "reference_audio_url" field was cleared in this mutation.
func (m *PronunciationAttemptMutation) ReferenceAudioURLCleared() bool {
	_, ok := m.clearedFields[pronunciationattempt.FieldReferenceAudioURL]
	return ok
}

// ResetReferenceAudioURL resets all changes to the "reference_audio_url" field.
func (m *PronunciationAttemptMutation) ResetReferenceAudioURL() {
	m.reference_audio_url = nil
	delete(m.clearedFields, pronunciationattempt.FieldReferenceAudioURL)
}

// SetSimilarityScore sets the "similarity_score" field.
func (m *PronunciationAttemptMutation) SetSimilarityScore(f float64) {
	m.similarity_score = &f
	m.addsimilarity_score = nil
}

// SimilarityScore returns the value of the "similarity_score" field in the mutation.
func (m *PronunciationAttemptMutation) SimilarityScore() (r float64, exists bool) {
	v := m.similarity_score
	if v == nil {
		return
	}
	return *v, true
}

// OldSimilarityScore returns the old "similarity_score" field's value of the PronunciationAttempt entity.
// If the PronunciationAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PronunciationAttemptMutation) OldSimilarityScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSimilarityScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSimilarityScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSimilarityScore: %w", err)
	}
	return oldValue.SimilarityScore, nil
}

// AddSimilarityScore adds f to the "similarity_score" field.
func (m *PronunciationAttemptMutation) AddSimilarityScore(f float64) {
	if m.addsimilarity_score != nil {
		*m.addsimilarity_score += f
	} else {
		m.addsimilarity_score = &f
	}
}

// AddedSimilarityScore returns the value that was added to the "similarity_score" field in this mutation.
func (m *PronunciationAttemptMutation) AddedSimilarityScore() (r float64, exists bool) {
	v := m.addsimilarity_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearSimilarityScore clears the value of the "similarity_score" field.
func (m *PronunciationAttemptMutation) ClearSimilarityScore() {
	m.similarity_score = nil
	m.addsimilarity_score = nil
	m.clearedFields[pronunciationattempt.FieldSimilarityScore] = struct{}{}
}

// SimilarityScoreCleared returns if the "similarity_score" field was cleared in this mutation.
func (m *PronunciationAttemptMutation) SimilarityScoreCleared() bool {
	_, ok := m.clearedFields[pronunciationattempt.FieldSimilarityScore]
	return ok
}

// ResetSimilarityScore resets all changes to the "similarity_score" field.
func (m *PronunciationAttemptMutation) ResetSimilarityScore() {
	m.similarity_score = nil
	m.addsimilarity_score = nil
	delete(m.clearedFields, pronunciationattempt.FieldSimilarityScore)
}

// SetPronunciationFeedback sets the "pronunciation_feedback" field.
func (m *PronunciationAttemptMutation) SetPronunciationFeedback(s string) {
	m.pronunciation_feedback = &s
}

// PronunciationFeedback returns the value of the "pronunciation_feedback" field in the mutation.
func (m *PronunciationAttemptMutation) PronunciationFeedback() (r string, exists bool) {
	v := m.pronunciation_feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldPronunciationFeedback returns the old "pronunciation_feedback" field's value of the PronunciationAttempt entity.
// If the PronunciationAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PronunciationAttemptMutation) OldPronunciationFeedback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPronunciationFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPronunciationFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPronunciationFeedback: %w", err)
	}
	return oldValue.PronunciationFeedback, nil
}

// ClearPronunciationFeedback clears the value of the "pronunciation_feedback" field.
func (m *PronunciationAttemptMutation) ClearPronunciationFeedback() {
	m.pronunciation_feedback = nil
	m.clearedFields[pronunciationattempt.FieldPronunciationFeedback] = struct{}{}
}

// PronunciationFeedbackCleared returns if the "pronunciation_feedback" field was cleared in this mutation.
func (m *PronunciationAttemptMutation) PronunciationFeedbackCleared() bool {
	_, ok := m.clearedFields[pronunciationattempt.FieldPronunciationFeedback]
	return ok
}

// ResetPronunciationFeedback resets all changes to the "pronunciation_feedback" field.
func (m *PronunciationAttemptMutation) ResetPronunciationFeedback() {
	m.pronunciation_feedback = nil
	delete(m.clearedFields, pronunciationattempt.FieldPronunciationFeedback)
}

// SetPhoneticAccuracy sets the "phonetic_accuracy" field.
func (m *PronunciationAttemptMutation) SetPhoneticAccuracy(value map[string]interface{}) {
	m.phonetic_accuracy = &value
}

// PhoneticAccuracy returns the value of the "phonetic_accuracy" field in the mutation.
func (m *PronunciationAttemptMutation) PhoneticAccuracy() (r map[string]interface{}, exists bool) {
	v := m.phonetic_accuracy
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneticAccuracy returns the old "phonetic_accuracy" field's value of the PronunciationAttempt entity.
// If the PronunciationAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PronunciationAttemptMutation) OldPhoneticAccuracy(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneticAccuracy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneticAccuracy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneticAccuracy: %w", err)
	}
	return oldValue.PhoneticAccuracy, nil
}

// ClearPhoneticAccuracy clears the value of the "phonetic_accuracy" field.
func (m *PronunciationAttemptMutation) ClearPhoneticAccuracy() {
	m.phonetic_accuracy = nil
	m.clearedFields[pronunciationattempt.FieldPhoneticAccuracy] = struct{}{}
}

// PhoneticAccuracyCleared returns if the "phonetic_accuracy" field was cleared in this mutation.
func (m *PronunciationAttemptMutation) PhoneticAccuracyCleared() bool {
	_, ok := m.clearedFields[pronunciationattempt.FieldPhoneticAccuracy]
	return ok
}

// ResetPhoneticAccuracy resets all changes to the "phonetic_accuracy" field.
func (m *PronunciationAttemptMutation) ResetPhoneticAccuracy() {
	m.phonetic_accuracy = nil
	delete(m.clearedFields, pronunciationattempt.FieldPhoneticAccuracy)
}

// SetAttemptDate sets the "attempt_date" field.
func (m *PronunciationAttemptMutation) SetAttemptDate(t time.Time) {
	m.attempt_date = &t
}

// AttemptDate returns the value of the "attempt_date" field in the mutation.
func (m *PronunciationAttemptMutation) AttemptDate() (r time.Time, exists bool) {
	v := m.attempt_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAttemptDate returns the old "attempt_date" field's value of the PronunciationAttempt entity.
// If the PronunciationAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PronunciationAttemptMutation) OldAttemptDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttemptDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttemptDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttemptDate: %w", err)
	}
	return oldValue.AttemptDate, nil
}

// ResetAttemptDate resets all changes to the "attempt_date" field.
func (m *PronunciationAttemptMutation) ResetAttemptDate() {
	m.attempt_date = nil
}

// SetWasSuccessful sets the "was_successful" field.
func (m *PronunciationAttemptMutation) SetWasSuccessful(b bool) {
	m.was_successful = &b
}

// WasSuccessful returns the value of the "was_successful" field in the mutation.
func (m *PronunciationAttemptMutation) WasSuccessful() (r bool, exists bool) {
	v := m.was_successful
	if v == nil {
		return
	}
	return *v, true
}

// OldWasSuccessful returns the old "was_successful" field's value of the PronunciationAttempt entity.
// If the PronunciationAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PronunciationAttemptMutation) OldWasSuccessful(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWasSuccessful is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWasSuccessful requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWasSuccessful: %w", err)
	}
	return oldValue.WasSuccessful, nil
}

// ClearWasSuccessful clears the value of the "was_successful" field.
func (m *PronunciationAttemptMutation) ClearWasSuccessful() {
	m.was_successful = nil
	m.clearedFields[pronunciationattempt.FieldWasSuccessful] = struct{}{}
}

// WasSuccessfulCleared returns if the "was_successful" field was cleared in this mutation.
func (m *PronunciationAttemptMutation) WasSuccessfulCleared() bool {
	_, ok := m.clearedFields[pronunciationattempt.FieldWasSuccessful]
	return ok
}

// ResetWasSuccessful resets all changes to the "was_successful" field.
func (m *PronunciationAttemptMutation) ResetWasSuccessful() {
	m.was_successful = nil
	delete(m.clearedFields, pronunciationattempt.FieldWasSuccessful)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PronunciationAttemptMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PronunciationAttemptMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PronunciationAttemptMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PronunciationAttemptMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PronunciationAttemptMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PronunciationAttemptMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetQuestionID sets the "question" edge to the Question entity by id.
func (m *PronunciationAttemptMutation) SetQuestionID(id int) {
	m.question = &id
}

// ClearQuestion clears the "question" edge to the Question entity.
func (m *PronunciationAttemptMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared reports if the "question" edge to the Question entity was cleared.
func (m *PronunciationAttemptMutation) QuestionCleared() bool {
	return m.clearedquestion
}

// QuestionID returns the "question" edge ID in the mutation.
func (m *PronunciationAttemptMutation) QuestionID() (id int, exists bool) {
	if m.question != nil {
		return *m.question, true
	}
	return
}

// QuestionIDs returns the "question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *PronunciationAttemptMutation) QuestionIDs() (ids []int) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *PronunciationAttemptMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// SetWordID sets the "word" edge to the Word entity by id.
func (m *PronunciationAttemptMutation) SetWordID(id int) {
	m.word = &id
}

// ClearWord clears the "word" edge to the Word entity.
func (m *PronunciationAttemptMutation) ClearWord() {
	m.clearedword = true
}

// WordCleared reports if the "word" edge to the Word entity was cleared.
func (m *PronunciationAttemptMutation) WordCleared() bool {
	return m.clearedword
}

// WordID returns the "word" edge ID in the mutation.
func (m *PronunciationAttemptMutation) WordID() (id int, exists bool) {
	if m.word != nil {
		return *m.word, true
	}
	return
}

// WordIDs returns the "word" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WordID instead. It exists only for internal usage by the builders.
func (m *PronunciationAttemptMutation) WordIDs() (ids []int) {
	if id := m.word; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWord resets all changes to the "word" edge.
func (m *PronunciationAttemptMutation) ResetWord() {
	m.word = nil
	m.clearedword = false
}

// Where appends a list predicates to the PronunciationAttemptMutation builder.
func (m *PronunciationAttemptMutation) Where(ps ...predicate.PronunciationAttempt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PronunciationAttemptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PronunciationAttemptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PronunciationAttempt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PronunciationAttemptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PronunciationAttemptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PronunciationAttempt).
func (m *PronunciationAttemptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PronunciationAttemptMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user_audio_url != nil {
		fields = append(fields, pronunciationattempt.FieldUserAudioURL)
	}
	if m.reference_audio_url != nil {
		fields = append(fields, pronunciationattempt.FieldReferenceAudioURL)
	}
	if m.similarity_score != nil {
		fields = append(fields, pronunciationattempt.FieldSimilarityScore)
	}
	if m.pronunciation_feedback != nil {
		fields = append(fields, pronunciationattempt.FieldPronunciationFeedback)
	}
	if m.phonetic_accuracy != nil {
		fields = append(fields, pronunciationattempt.FieldPhoneticAccuracy)
	}
	if m.attempt_date != nil {
		fields = append(fields, pronunciationattempt.FieldAttemptDate)
	}
	if m.was_successful != nil {
		fields = append(fields, pronunciationattempt.FieldWasSuccessful)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PronunciationAttemptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pronunciationattempt.FieldUserAudioURL:
		return m.UserAudioURL()
	case pronunciationattempt.FieldReferenceAudioURL:
		return m.ReferenceAudioURL()
	case pronunciationattempt.FieldSimilarityScore:
		return m.SimilarityScore()
	case pronunciationattempt.FieldPronunciationFeedback:
		return m.PronunciationFeedback()
	case pronunciationattempt.FieldPhoneticAccuracy:
		return m.PhoneticAccuracy()
	case pronunciationattempt.FieldAttemptDate:
		return m.AttemptDate()
	case pronunciationattempt.FieldWasSuccessful:
		return m.WasSuccessful()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PronunciationAttemptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pronunciationattempt.FieldUserAudioURL:
		return m.OldUserAudioURL(ctx)
	case pronunciationattempt.FieldReferenceAudioURL:
		return m.OldReferenceAudioURL(ctx)
	case pronunciationattempt.FieldSimilarityScore:
		return m.OldSimilarityScore(ctx)
	case pronunciationattempt.FieldPronunciationFeedback:
		return m.OldPronunciationFeedback(ctx)
	case pronunciationattempt.FieldPhoneticAccuracy:
		return m.OldPhoneticAccuracy(ctx)
	case pronunciationattempt.FieldAttemptDate:
		return m.OldAttemptDate(ctx)
	case pronunciationattempt.FieldWasSuccessful:
		return m.OldWasSuccessful(ctx)
	}
	return nil, fmt.Errorf("unknown PronunciationAttempt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PronunciationAttemptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pronunciationattempt.FieldUserAudioURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAudioURL(v)
		return nil
	case pronunciationattempt.FieldReferenceAudioURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceAudioURL(v)
		return nil
	case pronunciationattempt.FieldSimilarityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSimilarityScore(v)
		return nil
	case pronunciationattempt.FieldPronunciationFeedback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPronunciationFeedback(v)
		return nil
	case pronunciationattempt.FieldPhoneticAccuracy:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneticAccuracy(v)
		return nil
	case pronunciationattempt.FieldAttemptDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttemptDate(v)
		return nil
	case pronunciationattempt.FieldWasSuccessful:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWasSuccessful(v)
		return nil
	}
	return fmt.Errorf("unknown PronunciationAttempt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PronunciationAttemptMutation) AddedFields() []string {
	var fields []string
	if m.addsimilarity_score != nil {
		fields = append(fields, pronunciationattempt.FieldSimilarityScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PronunciationAttemptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pronunciationattempt.FieldSimilarityScore:
		return m.AddedSimilarityScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PronunciationAttemptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pronunciationattempt.FieldSimilarityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSimilarityScore(v)
		return nil
	}
	return fmt.Errorf("unknown PronunciationAttempt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PronunciationAttemptMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pronunciationattempt.FieldReferenceAudioURL) {
		fields = append(fields, pronunciationattempt.FieldReferenceAudioURL)
	}
	if m.FieldCleared(pronunciationattempt.FieldSimilarityScore) {
		fields = append(fields, pronunciationattempt.FieldSimilarityScore)
	}
	if m.FieldCleared(pronunciationattempt.FieldPronunciationFeedback) {
		fields = append(fields, pronunciationattempt.FieldPronunciationFeedback)
	}
	if m.FieldCleared(pronunciationattempt.FieldPhoneticAccuracy) {
		fields = append(fields, pronunciationattempt.FieldPhoneticAccuracy)
	}
	if m.FieldCleared(pronunciationattempt.FieldWasSuccessful) {
		fields = append(fields, pronunciationattempt.FieldWasSuccessful)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PronunciationAttemptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PronunciationAttemptMutation) ClearField(name string) error {
	switch name {
	case pronunciationattempt.FieldReferenceAudioURL:
		m.ClearReferenceAudioURL()
		return nil
	case pronunciationattempt.FieldSimilarityScore:
		m.ClearSimilarityScore()
		return nil
	case pronunciationattempt.FieldPronunciationFeedback:
		m.ClearPronunciationFeedback()
		return nil
	case pronunciationattempt.FieldPhoneticAccuracy:
		m.ClearPhoneticAccuracy()
		return nil
	case pronunciationattempt.FieldWasSuccessful:
		m.ClearWasSuccessful()
		return nil
	}
	return fmt.Errorf("unknown PronunciationAttempt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PronunciationAttemptMutation) ResetField(name string) error {
	switch name {
	case pronunciationattempt.FieldUserAudioURL:
		m.ResetUserAudioURL()
		return nil
	case pronunciationattempt.FieldReferenceAudioURL:
		m.ResetReferenceAudioURL()
		return nil
	case pronunciationattempt.FieldSimilarityScore:
		m.ResetSimilarityScore()
		return nil
	case pronunciationattempt.FieldPronunciationFeedback:
		m.ResetPronunciationFeedback()
		return nil
	case pronunciationattempt.FieldPhoneticAccuracy:
		m.ResetPhoneticAccuracy()
		return nil
	case pronunciationattempt.FieldAttemptDate:
		m.ResetAttemptDate()
		return nil
	case pronunciationattempt.FieldWasSuccessful:
		m.ResetWasSuccessful()
		return nil
	}
	return fmt.Errorf("unknown PronunciationAttempt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PronunciationAttemptMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, pronunciationattempt.EdgeUser)
	}
	if m.question != nil {
		edges = append(edges, pronunciationattempt.EdgeQuestion)
	}
	if m.word != nil {
		edges = append(edges, pronunciationattempt.EdgeWord)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PronunciationAttemptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pronunciationattempt.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case pronunciationattempt.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	case pronunciationattempt.EdgeWord:
		if id := m.word; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PronunciationAttemptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PronunciationAttemptMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PronunciationAttemptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, pronunciationattempt.EdgeUser)
	}
	if m.clearedquestion {
		edges = append(edges, pronunciationattempt.EdgeQuestion)
	}
	if m.clearedword {
		edges = append(edges, pronunciationattempt.EdgeWord)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PronunciationAttemptMutation) EdgeCleared(name string) bool {
	switch name {
	case pronunciationattempt.EdgeUser:
		return m.cleareduser
	case pronunciationattempt.EdgeQuestion:
		return m.clearedquestion
	case pronunciationattempt.EdgeWord:
		return m.clearedword
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PronunciationAttemptMutation) ClearEdge(name string) error {
	switch name {
	case pronunciationattempt.EdgeUser:
		m.ClearUser()
		return nil
	case pronunciationattempt.EdgeQuestion:
		m.ClearQuestion()
		return nil
	case pronunciationattempt.EdgeWord:
		m.ClearWord()
		return nil
	}
	return fmt.Errorf("unknown PronunciationAttempt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PronunciationAttemptMutation) ResetEdge(name string) error {
	switch name {
	case pronunciationattempt.EdgeUser:
		m.ResetUser()
		return nil
	case pronunciationattempt.EdgeQuestion:
		m.ResetQuestion()
		return nil
	case pronunciationattempt.EdgeWord:
		m.ResetWord()
		return nil
	}
	return fmt.Errorf("unknown PronunciationAttempt edge %s", name)
}

// QuestionMutation represents an operation that mutates the Question nodes in the graph.
type QuestionMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	question_type                 *string
	question_text                 *string
	correct_answer                *string
	difficulty_level              *string
	generated_at                  *time.Time
	is_active                     *bool
	options                       *[]string
	appendoptions                 []string
	hints                         *string
	clearedFields                 map[string]struct{}
	word                          *int
	clearedword                   bool
	question_reviews              map[int]struct{}
	removedquestion_reviews       map[int]struct{}
	clearedquestion_reviews       bool
	question_attempts             map[int]struct{}
	removedquestion_attempts      map[int]struct{}
	clearedquestion_attempts      bool
	pronunciation_attempts        map[int]struct{}
	removedpronunciation_attempts map[int]struct{}
	clearedpronunciation_attempts bool
	done                          bool
	oldValue                      func(context.Context) (*Question, error)
	predicates                    []predicate.Question
}

var _ ent.Mutation = (*QuestionMutation)(nil)

// questionOption allows management of the mutation configuration using functional options.
type questionOption func(*QuestionMutation)

// newQuestionMutation creates new mutation for the Question entity.
func newQuestionMutation(c config, op Op, opts ...questionOption) *QuestionMutation {
	m := &QuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQuestionID sets the ID field of the mutation.
func withQuestionID(id int) questionOption {
	return func(m *QuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *Question
		)
		m.oldValue = func(ctx context.Context) (*Question, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Question.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQuestion sets the old Question of the mutation.
func withQuestion(node *Question) questionOption {
	return func(m *QuestionMutation) {
		m.oldValue = func(context.Context) (*Question, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QuestionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QuestionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Question.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuestionType sets the "question_type" field.
func (m *QuestionMutation) SetQuestionType(s string) {
	m.question_type = &s
}

// QuestionType returns the value of the "question_type" field in the mutation.
func (m *QuestionMutation) QuestionType() (r string, exists bool) {
	v := m.question_type
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionType returns the old "question_type" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldQuestionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionType: %w", err)
	}
	return oldValue.QuestionType, nil
}

// ResetQuestionType resets all changes to the "question_type" field.
func (m *QuestionMutation) ResetQuestionType() {
	m.question_type = nil
}

// SetQuestionText sets the "question_text" field.
func (m *QuestionMutation) SetQuestionText(s string) {
	m.question_text = &s
}

// QuestionText returns the value of the "question_text" field in the mutation.
func (m *QuestionMutation) QuestionText() (r string, exists bool) {
	v := m.question_text
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionText returns the old "question_text" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldQuestionText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionText: %w", err)
	}
	return oldValue.QuestionText, nil
}

// ResetQuestionText resets all changes to the "question_text" field.
func (m *QuestionMutation) ResetQuestionText() {
	m.question_text = nil
}

// SetCorrectAnswer sets the "correct_answer" field.
func (m *QuestionMutation) SetCorrectAnswer(s string) {
	m.correct_answer = &s
}

// CorrectAnswer returns the value of the "correct_answer" field in the mutation.
func (m *QuestionMutation) CorrectAnswer() (r string, exists bool) {
	v := m.correct_answer
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrectAnswer returns the old "correct_answer" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldCorrectAnswer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrectAnswer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrectAnswer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrectAnswer: %w", err)
	}
	return oldValue.CorrectAnswer, nil
}

// ResetCorrectAnswer resets all changes to the "correct_answer" field.
func (m *QuestionMutation) ResetCorrectAnswer() {
	m.correct_answer = nil
}

// SetDifficultyLevel sets the "difficulty_level" field.
func (m *QuestionMutation) SetDifficultyLevel(s string) {
	m.difficulty_level = &s
}

// DifficultyLevel returns the value of the "difficulty_level" field in the mutation.
func (m *QuestionMutation) DifficultyLevel() (r string, exists bool) {
	v := m.difficulty_level
	if v == nil {
		return
	}
	return *v, true
}

// OldDifficultyLevel returns the old "difficulty_level" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldDifficultyLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDifficultyLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDifficultyLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDifficultyLevel: %w", err)
	}
	return oldValue.DifficultyLevel, nil
}

// ClearDifficultyLevel clears the value of the "difficulty_level" field.
func (m *QuestionMutation) ClearDifficultyLevel() {
	m.difficulty_level = nil
	m.clearedFields[question.FieldDifficultyLevel] = struct{}{}
}

// DifficultyLevelCleared returns if the "difficulty_level" field was cleared in this mutation.
func (m *QuestionMutation) DifficultyLevelCleared() bool {
	_, ok := m.clearedFields[question.FieldDifficultyLevel]
	return ok
}

// ResetDifficultyLevel resets all changes to the "difficulty_level" field.
func (m *QuestionMutation) ResetDifficultyLevel() {
	m.difficulty_level = nil
	delete(m.clearedFields, question.FieldDifficultyLevel)
}

// SetGeneratedAt sets the "generated_at" field.
func (m *QuestionMutation) SetGeneratedAt(t time.Time) {
	m.generated_at = &t
}

// GeneratedAt returns the value of the "generated_at" field in the mutation.
func (m *QuestionMutation) GeneratedAt() (r time.Time, exists bool) {
	v := m.generated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldGeneratedAt returns the old "generated_at" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldGeneratedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeneratedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeneratedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeneratedAt: %w", err)
	}
	return oldValue.GeneratedAt, nil
}

// ResetGeneratedAt resets all changes to the "generated_at" field.
func (m *QuestionMutation) ResetGeneratedAt() {
	m.generated_at = nil
}

// SetIsActive sets the "is_active" field.
func (m *QuestionMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *QuestionMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *QuestionMutation) ResetIsActive() {
	m.is_active = nil
}

// SetOptions sets the "options" field.
func (m *QuestionMutation) SetOptions(s []string) {
	m.options = &s
	m.appendoptions = nil
}

// Options returns the value of the "options" field in the mutation.
func (m *QuestionMutation) Options() (r []string, exists bool) {
	v := m.options
	if v == nil {
		return
	}
	return *v, true
}

// OldOptions returns the old "options" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldOptions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptions: %w", err)
	}
	return oldValue.Options, nil
}

// AppendOptions adds s to the "options" field.
func (m *QuestionMutation) AppendOptions(s []string) {
	m.appendoptions = append(m.appendoptions, s...)
}

// AppendedOptions returns the list of values that were appended to the "options" field in this mutation.
func (m *QuestionMutation) AppendedOptions() ([]string, bool) {
	if len(m.appendoptions) == 0 {
		return nil, false
	}
	return m.appendoptions, true
}

// ClearOptions clears the value of the "options" field.
func (m *QuestionMutation) ClearOptions() {
	m.options = nil
	m.appendoptions = nil
	m.clearedFields[question.FieldOptions] = struct{}{}
}

// OptionsCleared returns if the "options" field was cleared in this mutation.
func (m *QuestionMutation) OptionsCleared() bool {
	_, ok := m.clearedFields[question.FieldOptions]
	return ok
}

// ResetOptions resets all changes to the "options" field.
func (m *QuestionMutation) ResetOptions() {
	m.options = nil
	m.appendoptions = nil
	delete(m.clearedFields, question.FieldOptions)
}

// SetHints sets the "hints" field.
func (m *QuestionMutation) SetHints(s string) {
	m.hints = &s
}

// Hints returns the value of the "hints" field in the mutation.
func (m *QuestionMutation) Hints() (r string, exists bool) {
	v := m.hints
	if v == nil {
		return
	}
	return *v, true
}

// OldHints returns the old "hints" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldHints(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHints: %w", err)
	}
	return oldValue.Hints, nil
}

// ClearHints clears the value of the "hints" field.
func (m *QuestionMutation) ClearHints() {
	m.hints = nil
	m.clearedFields[question.FieldHints] = struct{}{}
}

// HintsCleared returns if the "hints" field was cleared in this mutation.
func (m *QuestionMutation) HintsCleared() bool {
	_, ok := m.clearedFields[question.FieldHints]
	return ok
}

// ResetHints resets all changes to the "hints" field.
func (m *QuestionMutation) ResetHints() {
	m.hints = nil
	delete(m.clearedFields, question.FieldHints)
}

// SetWordID sets the "word" edge to the Word entity by id.
func (m *QuestionMutation) SetWordID(id int) {
	m.word = &id
}

// ClearWord clears the "word" edge to the Word entity.
func (m *QuestionMutation) ClearWord() {
	m.clearedword = true
}

// WordCleared reports if the "word" edge to the Word entity was cleared.
func (m *QuestionMutation) WordCleared() bool {
	return m.clearedword
}

// WordID returns the "word" edge ID in the mutation.
func (m *QuestionMutation) WordID() (id int, exists bool) {
	if m.word != nil {
		return *m.word, true
	}
	return
}

// WordIDs returns the "word" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WordID instead. It exists only for internal usage by the builders.
func (m *QuestionMutation) WordIDs() (ids []int) {
	if id := m.word; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWord resets all changes to the "word" edge.
func (m *QuestionMutation) ResetWord() {
	m.word = nil
	m.clearedword = false
}

// AddQuestionReviewIDs adds the "question_reviews" edge to the QuestionReview entity by ids.
func (m *QuestionMutation) AddQuestionReviewIDs(ids ...int) {
	if m.question_reviews == nil {
		m.question_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.question_reviews[ids[i]] = struct{}{}
	}
}

// ClearQuestionReviews clears the "question_reviews" edge to the QuestionReview entity.
func (m *QuestionMutation) ClearQuestionReviews() {
	m.clearedquestion_reviews = true
}

// QuestionReviewsCleared reports if the "question_reviews" edge to the QuestionReview entity was cleared.
func (m *QuestionMutation) QuestionReviewsCleared() bool {
	return m.clearedquestion_reviews
}

// RemoveQuestionReviewIDs removes the "question_reviews" edge to the QuestionReview entity by IDs.
func (m *QuestionMutation) RemoveQuestionReviewIDs(ids ...int) {
	if m.removedquestion_reviews == nil {
		m.removedquestion_reviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.question_reviews, ids[i])
		m.removedquestion_reviews[ids[i]] = struct{}{}
	}
}

// RemovedQuestionReviews returns the removed IDs of the "question_reviews" edge to the QuestionReview entity.
func (m *QuestionMutation) RemovedQuestionReviewsIDs() (ids []int) {
	for id := range m.removedquestion_reviews {
		ids = append(ids, id)
	}
	return
}

// QuestionReviewsIDs returns the "question_reviews" edge IDs in the mutation.
func (m *QuestionMutation) QuestionReviewsIDs() (ids []int) {
	for id := range m.question_reviews {
		ids = append(ids, id)
	}
	return
}

// ResetQuestionReviews resets all changes to the "question_reviews" edge.
func (m *QuestionMutation) ResetQuestionReviews() {
	m.question_reviews = nil
	m.clearedquestion_reviews = false
	m.removedquestion_reviews = nil
}

// AddQuestionAttemptIDs adds the "question_attempts" edge to the QuestionAttempt entity by ids.
func (m *QuestionMutation) AddQuestionAttemptIDs(ids ...int) {
	if m.question_attempts == nil {
		m.question_attempts = make(map[int]struct{})
	}
	for i := range ids {
		m.question_attempts[ids[i]] = struct{}{}
	}
}

// ClearQuestionAttempts clears the "question_attempts" edge to the QuestionAttempt entity.
func (m *QuestionMutation) ClearQuestionAttempts() {
	m.clearedquestion_attempts = true
}

// QuestionAttemptsCleared reports if the "question_attempts" edge to the QuestionAttempt entity was cleared.
func (m *QuestionMutation) QuestionAttemptsCleared() bool {
	return m.clearedquestion_attempts
}

// RemoveQuestionAttemptIDs removes the "question_attempts" edge to the QuestionAttempt entity by IDs.
func (m *QuestionMutation) RemoveQuestionAttemptIDs(ids ...int) {
	if m.removedquestion_attempts == nil {
		m.removedquestion_attempts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.question_attempts, ids[i])
		m.removedquestion_attempts[ids[i]] = struct{}{}
	}
}

// RemovedQuestionAttempts returns the removed IDs of the "question_attempts" edge to the QuestionAttempt entity.
func (m *QuestionMutation) RemovedQuestionAttemptsIDs() (ids []int) {
	for id := range m.removedquestion_attempts {
		ids = append(ids, id)
	}
	return
}

// QuestionAttemptsIDs returns the "question_attempts" edge IDs in the mutation.
func (m *QuestionMutation) QuestionAttemptsIDs() (ids []int) {
	for id := range m.question_attempts {
		ids = append(ids, id)
	}
	return
}

// ResetQuestionAttempts resets all changes to the "question_attempts" edge.
func (m *QuestionMutation) ResetQuestionAttempts() {
	m.question_attempts = nil
	m.clearedquestion_attempts = false
	m.removedquestion_attempts = nil
}

// AddPronunciationAttemptIDs adds the "pronunciation_attempts" edge to the PronunciationAttempt entity by ids.
func (m *QuestionMutation) AddPronunciationAttemptIDs(ids ...int) {
	if m.pronunciation_attempts == nil {
		m.pronunciation_attempts = make(map[int]struct{})
	}
	for i := range ids {
		m.pronunciation_attempts[ids[i]] = struct{}{}
	}
}

// ClearPronunciationAttempts clears the "pronunciation_attempts" edge to the PronunciationAttempt entity.
func (m *QuestionMutation) ClearPronunciationAttempts() {
	m.clearedpronunciation_attempts = true
}

// PronunciationAttemptsCleared reports if the "pronunciation_attempts" edge to the PronunciationAttempt entity was cleared.
func (m *QuestionMutation) PronunciationAttemptsCleared() bool {
	return m.clearedpronunciation_attempts
}

// RemovePronunciationAttemptIDs removes the "pronunciation_attempts" edge to the PronunciationAttempt entity by IDs.
func (m *QuestionMutation) RemovePronunciationAttemptIDs(ids ...int) {
	if m.removedpronunciation_attempts == nil {
		m.removedpronunciation_attempts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pronunciation_attempts, ids[i])
		m.removedpronunciation_attempts[ids[i]] = struct{}{}
	}
}

// RemovedPronunciationAttempts returns the removed IDs of the "pronunciation_attempts" edge to the PronunciationAttempt entity.
func (m *QuestionMutation) RemovedPronunciationAttemptsIDs() (ids []int) {
	for id := range m.removedpronunciation_attempts {
		ids = append(ids, id)
	}
	return
}

// PronunciationAttemptsIDs returns the "pronunciation_attempts" edge IDs in the mutation.
func (m *QuestionMutation) PronunciationAttemptsIDs() (ids []int) {
	for id := range m.pronunciation_attempts {
		ids = append(ids, id)
	}
	return
}

// ResetPronunciationAttempts resets all changes to the "pronunciation_attempts" edge.
func (m *QuestionMutation) ResetPronunciationAttempts() {
	m.pronunciation_attempts = nil
	m.clearedpronunciation_attempts = false
	m.removedpronunciation_attempts = nil
}

// Where appends a list predicates to the QuestionMutation builder.
func (m *QuestionMutation) Where(ps ...predicate.Question) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QuestionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QuestionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Question, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QuestionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QuestionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Question).
func (m *QuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QuestionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.question_type != nil {
		fields = append(fields, question.FieldQuestionType)
	}
	if m.question_text != nil {
		fields = append(fields, question.FieldQuestionText)
	}
	if m.correct_answer != nil {
		fields = append(fields, question.FieldCorrectAnswer)
	}
	if m.difficulty_level != nil {
		fields = append(fields, question.FieldDifficultyLevel)
	}
	if m.generated_at != nil {
		fields = append(fields, question.FieldGeneratedAt)
	}
	if m.is_active != nil {
		fields = append(fields, question.FieldIsActive)
	}
	if m.options != nil {
		fields = append(fields, question.FieldOptions)
	}
	if m.hints != nil {
		fields = append(fields, question.FieldHints)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case question.FieldQuestionType:
		return m.QuestionType()
	case question.FieldQuestionText:
		return m.QuestionText()
	case question.FieldCorrectAnswer:
		return m.CorrectAnswer()
	case question.FieldDifficultyLevel:
		return m.DifficultyLevel()
	case question.FieldGeneratedAt:
		return m.GeneratedAt()
	case question.FieldIsActive:
		return m.IsActive()
	case question.FieldOptions:
		return m.Options()
	case question.FieldHints:
		return m.Hints()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case question.FieldQuestionType:
		return m.OldQuestionType(ctx)
	case question.FieldQuestionText:
		return m.OldQuestionText(ctx)
	case question.FieldCorrectAnswer:
		return m.OldCorrectAnswer(ctx)
	case question.FieldDifficultyLevel:
		return m.OldDifficultyLevel(ctx)
	case question.FieldGeneratedAt:
		return m.OldGeneratedAt(ctx)
	case question.FieldIsActive:
		return m.OldIsActive(ctx)
	case question.FieldOptions:
		return m.OldOptions(ctx)
	case question.FieldHints:
		return m.OldHints(ctx)
	}
	return nil, fmt.Errorf("unknown Question field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case question.FieldQuestionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionType(v)
		return nil
	case question.FieldQuestionText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionText(v)
		return nil
	case question.FieldCorrectAnswer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrectAnswer(v)
		return nil
	case question.FieldDifficultyLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDifficultyLevel(v)
		return nil
	case question.FieldGeneratedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeneratedAt(v)
		return nil
	case question.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case question.FieldOptions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptions(v)
		return nil
	case question.FieldHints:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHints(v)
		return nil
	}
	return fmt.Errorf("unknown Question field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QuestionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QuestionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Question numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QuestionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(question.FieldDifficultyLevel) {
		fields = append(fields, question.FieldDifficultyLevel)
	}
	if m.FieldCleared(question.FieldOptions) {
		fields = append(fields, question.FieldOptions)
	}
	if m.FieldCleared(question.FieldHints) {
		fields = append(fields, question.FieldHints)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QuestionMutation) ClearField(name string) error {
	switch name {
	case question.FieldDifficultyLevel:
		m.ClearDifficultyLevel()
		return nil
	case question.FieldOptions:
		m.ClearOptions()
		return nil
	case question.FieldHints:
		m.ClearHints()
		return nil
	}
	return fmt.Errorf("unknown Question nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QuestionMutation) ResetField(name string) error {
	switch name {
	case question.FieldQuestionType:
		m.ResetQuestionType()
		return nil
	case question.FieldQuestionText:
		m.ResetQuestionText()
		return nil
	case question.FieldCorrectAnswer:
		m.ResetCorrectAnswer()
		return nil
	case question.FieldDifficultyLevel:
		m.ResetDifficultyLevel()
		return nil
	case question.FieldGeneratedAt:
		m.ResetGeneratedAt()
		return nil
	case question.FieldIsActive:
		m.ResetIsActive()
		return nil
	case question.FieldOptions:
		m.ResetOptions()
		return nil
	case question.FieldHints:
		m.ResetHints()
		return nil
	}
	return fmt.Errorf("unknown Question field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.word != nil {
		edges = append(edges, question.EdgeWord)
	}
	if m.question_reviews != nil {
		edges = append(edges, question.EdgeQuestionReviews)
	}
	if m.question_attempts != nil {
		edges = append(edges, question.EdgeQuestionAttempts)
	}
	if m.pronunciation_attempts != nil {
		edges = append(edges, question.EdgePronunciationAttempts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case question.EdgeWord:
		if id := m.word; id != nil {
			return []ent.Value{*id}
		}
	case question.EdgeQuestionReviews:
		ids := make([]ent.Value, 0, len(m.question_reviews))
		for id := range m.question_reviews {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeQuestionAttempts:
		ids := make([]ent.Value, 0, len(m.question_attempts))
		for id := range m.question_attempts {
			ids = append(ids, id)
		}
		return ids
	case question.EdgePronunciationAttempts:
		ids := make([]ent.Value, 0, len(m.pronunciation_attempts))
		for id := range m.pronunciation_attempts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedquestion_reviews != nil {
		edges = append(edges, question.EdgeQuestionReviews)
	}
	if m.removedquestion_attempts != nil {
		edges = append(edges, question.EdgeQuestionAttempts)
	}
	if m.removedpronunciation_attempts != nil {
		edges = append(edges, question.EdgePronunciationAttempts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QuestionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case question.EdgeQuestionReviews:
		ids := make([]ent.Value, 0, len(m.removedquestion_reviews))
		for id := range m.removedquestion_reviews {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeQuestionAttempts:
		ids := make([]ent.Value, 0, len(m.removedquestion_attempts))
		for id := range m.removedquestion_attempts {
			ids = append(ids, id)
		}
		return ids
	case question.EdgePronunciationAttempts:
		ids := make([]ent.Value, 0, len(m.removedpronunciation_attempts))
		for id := range m.removedpronunciation_attempts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedword {
		edges = append(edges, question.EdgeWord)
	}
	if m.clearedquestion_reviews {
		edges = append(edges, question.EdgeQuestionReviews)
	}
	if m.clearedquestion_attempts {
		edges = append(edges, question.EdgeQuestionAttempts)
	}
	if m.clearedpronunciation_attempts {
		edges = append(edges, question.EdgePronunciationAttempts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case question.EdgeWord:
		return m.clearedword
	case question.EdgeQuestionReviews:
		return m.clearedquestion_reviews
	case question.EdgeQuestionAttempts:
		return m.clearedquestion_attempts
	case question.EdgePronunciationAttempts:
		return m.clearedpronunciation_attempts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QuestionMutation) ClearEdge(name string) error {
	switch name {
	case question.EdgeWord:
		m.ClearWord()
		return nil
	}
	return fmt.Errorf("unknown Question unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QuestionMutation) ResetEdge(name string) error {
	switch name {
	case question.EdgeWord:
		m.ResetWord()
		return nil
	case question.EdgeQuestionReviews:
		m.ResetQuestionReviews()
		return nil
	case question.EdgeQuestionAttempts:
		m.ResetQuestionAttempts()
		return nil
	case question.EdgePronunciationAttempts:
		m.ResetPronunciationAttempts()
		return nil
	}
	return fmt.Errorf("unknown Question edge %s", name)
}

// QuestionAttemptMutation represents an operation that mutates the QuestionAttempt nodes in the graph.
type QuestionAttemptMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	user_answer            *string
	ai_grade               *string
	ai_feedback            *string
	similarity_score       *float64
	addsimilarity_score    *float64
	quality_rating         *int
	addquality_rating      *int
	response_time_ms       *int
	addresponse_time_ms    *int
	was_correct            *bool
	needs_repeat           *bool
	attempt_date           *time.Time
	clearedFields          map[string]struct{}
	user                   *int
	cleareduser            bool
	question               *int
	clearedquestion        bool
	question_review        *int
	clearedquestion_review bool
	done                   bool
	oldValue               func(context.Context) (*QuestionAttempt, error)
	predicates             []predicate.QuestionAttempt
}

var _ ent.Mutation = (*QuestionAttemptMutation)(nil)

// questionattemptOption allows management of the mutation configuration using functional options.
type questionattemptOption func(*QuestionAttemptMutation)

// newQuestionAttemptMutation creates new mutation for the QuestionAttempt entity.
func newQuestionAttemptMutation(c config, op Op, opts ...questionattemptOption) *QuestionAttemptMutation {
	m := &QuestionAttemptMutation{
		config:        c,
		op:            op,
		typ:           TypeQuestionAttempt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQuestionAttemptID sets the ID field of the mutation.
func withQuestionAttemptID(id int) questionattemptOption {
	return func(m *QuestionAttemptMutation) {
		var (
			err   error
			once  sync.Once
			value *QuestionAttempt
		)
		m.oldValue = func(ctx context.Context) (*QuestionAttempt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().QuestionAttempt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQuestionAttempt sets the old QuestionAttempt of the mutation.
func withQuestionAttempt(node *QuestionAttempt) questionattemptOption {
	return func(m *QuestionAttemptMutation) {
		m.oldValue = func(context.Context) (*QuestionAttempt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QuestionAttemptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QuestionAttemptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QuestionAttemptMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QuestionAttemptMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().QuestionAttempt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserAnswer sets the "user_answer" field.
func (m *QuestionAttemptMutation) SetUserAnswer(s string) {
	m.user_answer = &s
}

// UserAnswer returns the value of the "user_answer" field in the mutation.
func (m *QuestionAttemptMutation) UserAnswer() (r string, exists bool) {
	v := m.user_answer
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAnswer returns the old "user_answer" field's value of the QuestionAttempt entity.
// If the QuestionAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionAttemptMutation) OldUserAnswer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAnswer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAnswer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAnswer: %w", err)
	}
	return oldValue.UserAnswer, nil
}

// ClearUserAnswer clears the value of the "user_answer" field.
func (m *QuestionAttemptMutation) ClearUserAnswer() {
	m.user_answer = nil
	m.clearedFields[questionattempt.FieldUserAnswer] = struct{}{}
}

// UserAnswerCleared returns if the "user_answer" field was cleared in this mutation.
func (m *QuestionAttemptMutation) UserAnswerCleared() bool {
	_, ok := m.clearedFields[questionattempt.FieldUserAnswer]
	return ok
}

// ResetUserAnswer resets all changes to the "user_answer" field.
func (m *QuestionAttemptMutation) ResetUserAnswer() {
	m.user_answer = nil
	delete(m.clearedFields, questionattempt.FieldUserAnswer)
}

// SetAiGrade sets the "ai_grade" field.
func (m *QuestionAttemptMutation) SetAiGrade(s string) {
	m.ai_grade = &s
}

// AiGrade returns the value of the "ai_grade" field in the mutation.
func (m *QuestionAttemptMutation) AiGrade() (r string, exists bool) {
	v := m.ai_grade
	if v == nil {
		return
	}
	return *v, true
}

// OldAiGrade returns the old "ai_grade" field's value of the QuestionAttempt entity.
// If the QuestionAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionAttemptMutation) OldAiGrade(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAiGrade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAiGrade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAiGrade: %w", err)
	}
	return oldValue.AiGrade, nil
}

// ClearAiGrade clears the value of the "ai_grade" field.
func (m *QuestionAttemptMutation) ClearAiGrade() {
	m.ai_grade = nil
	m.clearedFields[questionattempt.FieldAiGrade] = struct{}{}
}

// AiGradeCleared returns if the "ai_grade" field was cleared in this mutation.
func (m *QuestionAttemptMutation) AiGradeCleared() bool {
	_, ok := m.clearedFields[questionattempt.FieldAiGrade]
	return ok
}

// ResetAiGrade resets all changes to the "ai_grade" field.
func (m *QuestionAttemptMutation) ResetAiGrade() {
	m.ai_grade = nil
	delete(m.clearedFields, questionattempt.FieldAiGrade)
}

// SetAiFeedback sets the "ai_feedback" field.
func (m *QuestionAttemptMutation) SetAiFeedback(s string) {
	m.ai_feedback = &s
}

// AiFeedback returns the value of the "ai_feedback" field in the mutation.
func (m *QuestionAttemptMutation) AiFeedback() (r string, exists bool) {
	v := m.ai_feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldAiFeedback returns the old "ai_feedback" field's value of the QuestionAttempt entity.
// If the QuestionAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionAttemptMutation) OldAiFeedback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAiFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAiFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAiFeedback: %w", err)
	}
	return oldValue.AiFeedback, nil
}

// ClearAiFeedback clears the value of the "ai_feedback" field.
func (m *QuestionAttemptMutation) ClearAiFeedback() {
	m.ai_feedback = nil
	m.clearedFields[questionattempt.FieldAiFeedback] = struct{}{}
}

// AiFeedbackCleared returns if the "ai_feedback" field was cleared in this mutation.
func (m *QuestionAttemptMutation) AiFeedbackCleared() bool {
	_, ok := m.clearedFields[questionattempt.FieldAiFeedback]
	return ok
}

// ResetAiFeedback resets all changes to the "ai_feedback" field.
func (m *QuestionAttemptMutation) ResetAiFeedback() {
	m.ai_feedback = nil
	delete(m.clearedFields, questionattempt.FieldAiFeedback)
}

// SetSimilarityScore sets the "similarity_score" field.
func (m *QuestionAttemptMutation) SetSimilarityScore(f float64) {
	m.similarity_score = &f
	m.addsimilarity_score = nil
}

// SimilarityScore returns the value of the "similarity_score" field in the mutation.
func (m *QuestionAttemptMutation) SimilarityScore() (r float64, exists bool) {
	v := m.similarity_score
	if v == nil {
		return
	}
	return *v, true
}

// OldSimilarityScore returns the old "similarity_score" field's value of the QuestionAttempt entity.
// If the QuestionAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionAttemptMutation) OldSimilarityScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSimilarityScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSimilarityScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSimilarityScore: %w", err)
	}
	return oldValue.SimilarityScore, nil
}

// AddSimilarityScore adds f to the "similarity_score" field.
func (m *QuestionAttemptMutation) AddSimilarityScore(f float64) {
	if m.addsimilarity_score != nil {
		*m.addsimilarity_score += f
	} else {
		m.addsimilarity_score = &f
	}
}

// AddedSimilarityScore returns the value that was added to the "similarity_score" field in this mutation.
func (m *QuestionAttemptMutation) AddedSimilarityScore() (r float64, exists bool) {
	v := m.addsimilarity_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearSimilarityScore clears the value of the "similarity_score" field.
func (m *QuestionAttemptMutation) ClearSimilarityScore() {
	m.similarity_score = nil
	m.addsimilarity_score = nil
	m.clearedFields[questionattempt.FieldSimilarityScore] = struct{}{}
}

// SimilarityScoreCleared returns if the "similarity_score" field was cleared in this mutation.
func (m *QuestionAttemptMutation) SimilarityScoreCleared() bool {
	_, ok := m.clearedFields[questionattempt.FieldSimilarityScore]
	return ok
}

// ResetSimilarityScore resets all changes to the "similarity_score" field.
func (m *QuestionAttemptMutation) ResetSimilarityScore() {
	m.similarity_score = nil
	m.addsimilarity_score = nil
	delete(m.clearedFields, questionattempt.FieldSimilarityScore)
}

// SetQualityRating sets the "quality_rating" field.
func (m *QuestionAttemptMutation) SetQualityRating(i int) {
	m.quality_rating = &i
	m.addquality_rating = nil
}

// QualityRating returns the value of the "quality_rating" field in the mutation.
func (m *QuestionAttemptMutation) QualityRating() (r int, exists bool) {
	v := m.quality_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityRating returns the old "quality_rating" field's value of the QuestionAttempt entity.
// If the QuestionAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionAttemptMutation) OldQualityRating(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityRating: %w", err)
	}
	return oldValue.QualityRating, nil
}

// AddQualityRating adds i to the "quality_rating" field.
func (m *QuestionAttemptMutation) AddQualityRating(i int) {
	if m.addquality_rating != nil {
		*m.addquality_rating += i
	} else {
		m.addquality_rating = &i
	}
}

// AddedQualityRating returns the value that was added to the "quality_rating" field in this mutation.
func (m *QuestionAttemptMutation) AddedQualityRating() (r int, exists bool) {
	v := m.addquality_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearQualityRating clears the value of the "quality_rating" field.
func (m *QuestionAttemptMutation) ClearQualityRating() {
	m.quality_rating = nil
	m.addquality_rating = nil
	m.clearedFields[questionattempt.FieldQualityRating] = struct{}{}
}

// QualityRatingCleared returns if the "quality_rating" field was cleared in this mutation.
func (m *QuestionAttemptMutation) QualityRatingCleared() bool {
	_, ok := m.clearedFields[questionattempt.FieldQualityRating]
	return ok
}

// ResetQualityRating resets all changes to the "quality_rating" field.
func (m *QuestionAttemptMutation) ResetQualityRating() {
	m.quality_rating = nil
	m.addquality_rating = nil
	delete(m.clearedFields, questionattempt.FieldQualityRating)
}

// SetResponseTimeMs sets the "response_time_ms" field.
func (m *QuestionAttemptMutation) SetResponseTimeMs(i int) {
	m.response_time_ms = &i
	m.addresponse_time_ms = nil
}

// ResponseTimeMs returns the value of the "response_time_ms" field in the mutation.
func (m *QuestionAttemptMutation) ResponseTimeMs() (r int, exists bool) {
	v := m.response_time_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseTimeMs returns the old "response_time_ms" field's value of the QuestionAttempt entity.
// If the QuestionAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionAttemptMutation) OldResponseTimeMs(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseTimeMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseTimeMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseTimeMs: %w", err)
	}
	return oldValue.ResponseTimeMs, nil
}

// AddResponseTimeMs adds i to the "response_time_ms" field.
func (m *QuestionAttemptMutation) AddResponseTimeMs(i int) {
	if m.addresponse_time_ms != nil {
		*m.addresponse_time_ms += i
	} else {
		m.addresponse_time_ms = &i
	}
}

// AddedResponseTimeMs returns the value that was added to the "response_time_ms" field in this mutation.
func (m *QuestionAttemptMutation) AddedResponseTimeMs() (r int, exists bool) {
	v := m.addresponse_time_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearResponseTimeMs clears the value of the "response_time_ms" field.
func (m *QuestionAttemptMutation) ClearResponseTimeMs() {
	m.response_time_ms = nil
	m.addresponse_time_ms = nil
	m.clearedFields[questionattempt.FieldResponseTimeMs] = struct{}{}
}

// ResponseTimeMsCleared returns if the "response_time_ms" field was cleared in this mutation.
func (m *QuestionAttemptMutation) ResponseTimeMsCleared() bool {
	_, ok := m.clearedFields[questionattempt.FieldResponseTimeMs]
	return ok
}

// ResetResponseTimeMs resets all changes to the "response_time_ms" field.
func (m *QuestionAttemptMutation) ResetResponseTimeMs() {
	m.response_time_ms = nil
	m.addresponse_time_ms = nil
	delete(m.clearedFields, questionattempt.FieldResponseTimeMs)
}

// SetWasCorrect sets the "was_correct" field.
func (m *QuestionAttemptMutation) SetWasCorrect(b bool) {
	m.was_correct = &b
}

// WasCorrect returns the value of the "was_correct" field in the mutation.
func (m *QuestionAttemptMutation) WasCorrect() (r bool, exists bool) {
	v := m.was_correct
	if v == nil {
		return
	}
	return *v, true
}

// OldWasCorrect returns the old "was_correct" field's value of the QuestionAttempt entity.
// If the QuestionAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionAttemptMutation) OldWasCorrect(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWasCorrect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWasCorrect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWasCorrect: %w", err)
	}
	return oldValue.WasCorrect, nil
}

// ResetWasCorrect resets all changes to the "was_correct" field.
func (m *QuestionAttemptMutation) ResetWasCorrect() {
	m.was_correct = nil
}

// SetNeedsRepeat sets the "needs_repeat" field.
func (m *QuestionAttemptMutation) SetNeedsRepeat(b bool) {
	m.needs_repeat = &b
}

// NeedsRepeat returns the value of the "needs_repeat" field in the mutation.
func (m *QuestionAttemptMutation) NeedsRepeat() (r bool, exists bool) {
	v := m.needs_repeat
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedsRepeat returns the old "needs_repeat" field's value of the QuestionAttempt entity.
// If the QuestionAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionAttemptMutation) OldNeedsRepeat(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNeedsRepeat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNeedsRepeat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedsRepeat: %w", err)
	}
	return oldValue.NeedsRepeat, nil
}

// ResetNeedsRepeat resets all changes to the "needs_repeat" field.
func (m *QuestionAttemptMutation) ResetNeedsRepeat() {
	m.needs_repeat = nil
}

// SetAttemptDate sets the "attempt_date" field.
func (m *QuestionAttemptMutation) SetAttemptDate(t time.Time) {
	m.attempt_date = &t
}

// AttemptDate returns the value of the "attempt_date" field in the mutation.
func (m *QuestionAttemptMutation) AttemptDate() (r time.Time, exists bool) {
	v := m.attempt_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAttemptDate returns the old "attempt_date" field's value of the QuestionAttempt entity.
// If the QuestionAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionAttemptMutation) OldAttemptDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttemptDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttemptDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttemptDate: %w", err)
	}
	return oldValue.AttemptDate, nil
}

// ResetAttemptDate resets all changes to the "attempt_date" field.
func (m *QuestionAttemptMutation) ResetAttemptDate() {
	m.attempt_date = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *QuestionAttemptMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *QuestionAttemptMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *QuestionAttemptMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *QuestionAttemptMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *QuestionAttemptMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *QuestionAttemptMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetQuestionID sets the "question" edge to the Question entity by id.
func (m *QuestionAttemptMutation) SetQuestionID(id int) {
	m.question = &id
}

// ClearQuestion clears the "question" edge to the Question entity.
func (m *QuestionAttemptMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared reports if the "question" edge to the Question entity was cleared.
func (m *QuestionAttemptMutation) QuestionCleared() bool {
	return m.clearedquestion
}

// QuestionID returns the "question" edge ID in the mutation.
func (m *QuestionAttemptMutation) QuestionID() (id int, exists bool) {
	if m.question != nil {
		return *m.question, true
	}
	return
}

// QuestionIDs returns the "question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *QuestionAttemptMutation) QuestionIDs() (ids []int) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *QuestionAttemptMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// SetQuestionReviewID sets the "question_review" edge to the QuestionReview entity by id.
func (m *QuestionAttemptMutation) SetQuestionReviewID(id int) {
	m.question_review = &id
}

// ClearQuestionReview clears the "question_review" edge to the QuestionReview entity.
func (m *QuestionAttemptMutation) ClearQuestionReview() {
	m.clearedquestion_review = true
}

// QuestionReviewCleared reports if the "question_review" edge to the QuestionReview entity was cleared.
func (m *QuestionAttemptMutation) QuestionReviewCleared() bool {
	return m.clearedquestion_review
}

// QuestionReviewID returns the "question_review" edge ID in the mutation.
func (m *QuestionAttemptMutation) QuestionReviewID() (id int, exists bool) {
	if m.question_review != nil {
		return *m.question_review, true
	}
	return
}

// QuestionReviewIDs returns the "question_review" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionReviewID instead. It exists only for internal usage by the builders.
func (m *QuestionAttemptMutation) QuestionReviewIDs() (ids []int) {
	if id := m.question_review; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestionReview resets all changes to the "question_review" edge.
func (m *QuestionAttemptMutation) ResetQuestionReview() {
	m.question_review = nil
	m.clearedquestion_review = false
}

// Where appends a list predicates to the QuestionAttemptMutation builder.
func (m *QuestionAttemptMutation) Where(ps ...predicate.QuestionAttempt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QuestionAttemptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QuestionAttemptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.QuestionAttempt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QuestionAttemptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QuestionAttemptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (QuestionAttempt).
func (m *QuestionAttemptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QuestionAttemptMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.user_answer != nil {
		fields = append(fields, questionattempt.FieldUserAnswer)
	}
	if m.ai_grade != nil {
		fields = append(fields, questionattempt.FieldAiGrade)
	}
	if m.ai_feedback != nil {
		fields = append(fields, questionattempt.FieldAiFeedback)
	}
	if m.similarity_score != nil {
		fields = append(fields, questionattempt.FieldSimilarityScore)
	}
	if m.quality_rating != nil {
		fields = append(fields, questionattempt.FieldQualityRating)
	}
	if m.response_time_ms != nil {
		fields = append(fields, questionattempt.FieldResponseTimeMs)
	}
	if m.was_correct != nil {
		fields = append(fields, questionattempt.FieldWasCorrect)
	}
	if m.needs_repeat != nil {
		fields = append(fields, questionattempt.FieldNeedsRepeat)
	}
	if m.attempt_date != nil {
		fields = append(fields, questionattempt.FieldAttemptDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QuestionAttemptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case questionattempt.FieldUserAnswer:
		return m.UserAnswer()
	case questionattempt.FieldAiGrade:
		return m.AiGrade()
	case questionattempt.FieldAiFeedback:
		return m.AiFeedback()
	case questionattempt.FieldSimilarityScore:
		return m.SimilarityScore()
	case questionattempt.FieldQualityRating:
		return m.QualityRating()
	case questionattempt.FieldResponseTimeMs:
		return m.ResponseTimeMs()
	case questionattempt.FieldWasCorrect:
		return m.WasCorrect()
	case questionattempt.FieldNeedsRepeat:
		return m.NeedsRepeat()
	case questionattempt.FieldAttemptDate:
		return m.AttemptDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QuestionAttemptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case questionattempt.FieldUserAnswer:
		return m.OldUserAnswer(ctx)
	case questionattempt.FieldAiGrade:
		return m.OldAiGrade(ctx)
	case questionattempt.FieldAiFeedback:
		return m.OldAiFeedback(ctx)
	case questionattempt.FieldSimilarityScore:
		return m.OldSimilarityScore(ctx)
	case questionattempt.FieldQualityRating:
		return m.OldQualityRating(ctx)
	case questionattempt.FieldResponseTimeMs:
		return m.OldResponseTimeMs(ctx)
	case questionattempt.FieldWasCorrect:
		return m.OldWasCorrect(ctx)
	case questionattempt.FieldNeedsRepeat:
		return m.OldNeedsRepeat(ctx)
	case questionattempt.FieldAttemptDate:
		return m.OldAttemptDate(ctx)
	}
	return nil, fmt.Errorf("unknown QuestionAttempt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionAttemptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case questionattempt.FieldUserAnswer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAnswer(v)
		return nil
	case questionattempt.FieldAiGrade:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAiGrade(v)
		return nil
	case questionattempt.FieldAiFeedback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAiFeedback(v)
		return nil
	case questionattempt.FieldSimilarityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSimilarityScore(v)
		return nil
	case questionattempt.FieldQualityRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityRating(v)
		return nil
	case questionattempt.FieldResponseTimeMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseTimeMs(v)
		return nil
	case questionattempt.FieldWasCorrect:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWasCorrect(v)
		return nil
	case questionattempt.FieldNeedsRepeat:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedsRepeat(v)
		return nil
	case questionattempt.FieldAttemptDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttemptDate(v)
		return nil
	}
	return fmt.Errorf("unknown QuestionAttempt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QuestionAttemptMutation) AddedFields() []string {
	var fields []string
	if m.addsimilarity_score != nil {
		fields = append(fields, questionattempt.FieldSimilarityScore)
	}
	if m.addquality_rating != nil {
		fields = append(fields, questionattempt.FieldQualityRating)
	}
	if m.addresponse_time_ms != nil {
		fields = append(fields, questionattempt.FieldResponseTimeMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QuestionAttemptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case questionattempt.FieldSimilarityScore:
		return m.AddedSimilarityScore()
	case questionattempt.FieldQualityRating:
		return m.AddedQualityRating()
	case questionattempt.FieldResponseTimeMs:
		return m.AddedResponseTimeMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionAttemptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case questionattempt.FieldSimilarityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSimilarityScore(v)
		return nil
	case questionattempt.FieldQualityRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQualityRating(v)
		return nil
	case questionattempt.FieldResponseTimeMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResponseTimeMs(v)
		return nil
	}
	return fmt.Errorf("unknown QuestionAttempt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QuestionAttemptMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(questionattempt.FieldUserAnswer) {
		fields = append(fields, questionattempt.FieldUserAnswer)
	}
	if m.FieldCleared(questionattempt.FieldAiGrade) {
		fields = append(fields, questionattempt.FieldAiGrade)
	}
	if m.FieldCleared(questionattempt.FieldAiFeedback) {
		fields = append(fields, questionattempt.FieldAiFeedback)
	}
	if m.FieldCleared(questionattempt.FieldSimilarityScore) {
		fields = append(fields, questionattempt.FieldSimilarityScore)
	}
	if m.FieldCleared(questionattempt.FieldQualityRating) {
		fields = append(fields, questionattempt.FieldQualityRating)
	}
	if m.FieldCleared(questionattempt.FieldResponseTimeMs) {
		fields = append(fields, questionattempt.FieldResponseTimeMs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QuestionAttemptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QuestionAttemptMutation) ClearField(name string) error {
	switch name {
	case questionattempt.FieldUserAnswer:
		m.ClearUserAnswer()
		return nil
	case questionattempt.FieldAiGrade:
		m.ClearAiGrade()
		return nil
	case questionattempt.FieldAiFeedback:
		m.ClearAiFeedback()
		return nil
	case questionattempt.FieldSimilarityScore:
		m.ClearSimilarityScore()
		return nil
	case questionattempt.FieldQualityRating:
		m.ClearQualityRating()
		return nil
	case questionattempt.FieldResponseTimeMs:
		m.ClearResponseTimeMs()
		return nil
	}
	return fmt.Errorf("unknown QuestionAttempt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QuestionAttemptMutation) ResetField(name string) error {
	switch name {
	case questionattempt.FieldUserAnswer:
		m.ResetUserAnswer()
		return nil
	case questionattempt.FieldAiGrade:
		m.ResetAiGrade()
		return nil
	case questionattempt.FieldAiFeedback:
		m.ResetAiFeedback()
		return nil
	case questionattempt.FieldSimilarityScore:
		m.ResetSimilarityScore()
		return nil
	case questionattempt.FieldQualityRating:
		m.ResetQualityRating()
		return nil
	case questionattempt.FieldResponseTimeMs:
		m.ResetResponseTimeMs()
		return nil
	case questionattempt.FieldWasCorrect:
		m.ResetWasCorrect()
		return nil
	case questionattempt.FieldNeedsRepeat:
		m.ResetNeedsRepeat()
		return nil
	case questionattempt.FieldAttemptDate:
		m.ResetAttemptDate()
		return nil
	}
	return fmt.Errorf("unknown QuestionAttempt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QuestionAttemptMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, questionattempt.EdgeUser)
	}
	if m.question != nil {
		edges = append(edges, questionattempt.EdgeQuestion)
	}
	if m.question_review != nil {
		edges = append(edges, questionattempt.EdgeQuestionReview)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QuestionAttemptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case questionattempt.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case questionattempt.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	case questionattempt.EdgeQuestionReview:
		if id := m.question_review; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QuestionAttemptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QuestionAttemptMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QuestionAttemptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, questionattempt.EdgeUser)
	}
	if m.clearedquestion {
		edges = append(edges, questionattempt.EdgeQuestion)
	}
	if m.clearedquestion_review {
		edges = append(edges, questionattempt.EdgeQuestionReview)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QuestionAttemptMutation) EdgeCleared(name string) bool {
	switch name {
	case questionattempt.EdgeUser:
		return m.cleareduser
	case questionattempt.EdgeQuestion:
		return m.clearedquestion
	case questionattempt.EdgeQuestionReview:
		return m.clearedquestion_review
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QuestionAttemptMutation) ClearEdge(name string) error {
	switch name {
	case questionattempt.EdgeUser:
		m.ClearUser()
		return nil
	case questionattempt.EdgeQuestion:
		m.ClearQuestion()
		return nil
	case questionattempt.EdgeQuestionReview:
		m.ClearQuestionReview()
		return nil
	}
	return fmt.Errorf("unknown QuestionAttempt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QuestionAttemptMutation) ResetEdge(name string) error {
	switch name {
	case questionattempt.EdgeUser:
		m.ResetUser()
		return nil
	case questionattempt.EdgeQuestion:
		m.ResetQuestion()
		return nil
	case questionattempt.EdgeQuestionReview:
		m.ResetQuestionReview()
		return nil
	}
	return fmt.Errorf("unknown QuestionAttempt edge %s", name)
}

// QuestionReviewMutation represents an operation that mutates the QuestionReview nodes in the graph.
type QuestionReviewMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	ease_factor              *float64
	addease_factor           *float64
	interval_days            *int
	addinterval_days         *int
	repetition_count         *int
	addrepetition_count      *int
	next_review_date         *time.Time
	last_reviewed_at         *time.Time
	is_due                   *bool
	total_attempts           *int
	addtotal_attempts        *int
	correct_attempts         *int
	addcorrect_attempts      *int
	accuracy_rate            *float64
	addaccuracy_rate         *float64
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	user                     *int
	cleareduser              bool
	question                 *int
	clearedquestion          bool
	question_attempts        map[int]struct{}
	removedquestion_attempts map[int]struct{}
	clearedquestion_attempts bool
	done                     bool
	oldValue                 func(context.Context) (*QuestionReview, error)
	predicates               []predicate.QuestionReview
}

var _ ent.Mutation = (*QuestionReviewMutation)(nil)

// questionreviewOption allows management of the mutation configuration using functional options.
type questionreviewOption func(*QuestionReviewMutation)

// newQuestionReviewMutation creates new mutation for the QuestionReview entity.
func newQuestionReviewMutation(c config, op Op, opts ...questionreviewOption) *QuestionReviewMutation {
	m := &QuestionReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeQuestionReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQuestionReviewID sets the ID field of the mutation.
func withQuestionReviewID(id int) questionreviewOption {
	return func(m *QuestionReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *QuestionReview
		)
		m.oldValue = func(ctx context.Context) (*QuestionReview, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().QuestionReview.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQuestionReview sets the old QuestionReview of the mutation.
func withQuestionReview(node *QuestionReview) questionreviewOption {
	return func(m *QuestionReviewMutation) {
		m.oldValue = func(context.Context) (*QuestionReview, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QuestionReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QuestionReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QuestionReviewMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QuestionReviewMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().QuestionReview.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEaseFactor sets the "ease_factor" field.
func (m *QuestionReviewMutation) SetEaseFactor(f float64) {
	m.ease_factor = &f
	m.addease_factor = nil
}

// EaseFactor returns the value of the "ease_factor" field in the mutation.
func (m *QuestionReviewMutation) EaseFactor() (r float64, exists bool) {
	v := m.ease_factor
	if v == nil {
		return
	}
	return *v, true
}

// OldEaseFactor returns the old "ease_factor" field's value of the QuestionReview entity.
// If the QuestionReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionReviewMutation) OldEaseFactor(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEaseFactor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEaseFactor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEaseFactor: %w", err)
	}
	return oldValue.EaseFactor, nil
}

// AddEaseFactor adds f to the "ease_factor" field.
func (m *QuestionReviewMutation) AddEaseFactor(f float64) {
	if m.addease_factor != nil {
		*m.addease_factor += f
	} else {
		m.addease_factor = &f
	}
}

// AddedEaseFactor returns the value that was added to the "ease_factor" field in this mutation.
func (m *QuestionReviewMutation) AddedEaseFactor() (r float64, exists bool) {
	v := m.addease_factor
	if v == nil {
		return
	}
	return *v, true
}

// ResetEaseFactor resets all changes to the "ease_factor" field.
func (m *QuestionReviewMutation) ResetEaseFactor() {
	m.ease_factor = nil
	m.addease_factor = nil
}

// SetIntervalDays sets the "interval_days" field.
func (m *QuestionReviewMutation) SetIntervalDays(i int) {
	m.interval_days = &i
	m.addinterval_days = nil
}

// IntervalDays returns the value of the "interval_days" field in the mutation.
func (m *QuestionReviewMutation) IntervalDays() (r int, exists bool) {
	v := m.interval_days
	if v == nil {
		return
	}
	return *v, true
}

// OldIntervalDays returns the old "interval_days" field's value of the QuestionReview entity.
// If the QuestionReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionReviewMutation) OldIntervalDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntervalDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntervalDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntervalDays: %w", err)
	}
	return oldValue.IntervalDays, nil
}

// AddIntervalDays adds i to the "interval_days" field.
func (m *QuestionReviewMutation) AddIntervalDays(i int) {
	if m.addinterval_days != nil {
		*m.addinterval_days += i
	} else {
		m.addinterval_days = &i
	}
}

// AddedIntervalDays returns the value that was added to the "interval_days" field in this mutation.
func (m *QuestionReviewMutation) AddedIntervalDays() (r int, exists bool) {
	v := m.addinterval_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetIntervalDays resets all changes to the "interval_days" field.
func (m *QuestionReviewMutation) ResetIntervalDays() {
	m.interval_days = nil
	m.addinterval_days = nil
}

// SetRepetitionCount sets the "repetition_count" field.
func (m *QuestionReviewMutation) SetRepetitionCount(i int) {
	m.repetition_count = &i
	m.addrepetition_count = nil
}

// RepetitionCount returns the value of the "repetition_count" field in the mutation.
func (m *QuestionReviewMutation) RepetitionCount() (r int, exists bool) {
	v := m.repetition_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRepetitionCount returns the old "repetition_count" field's value of the QuestionReview entity.
// If the QuestionReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionReviewMutation) OldRepetitionCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepetitionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepetitionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepetitionCount: %w", err)
	}
	return oldValue.RepetitionCount, nil
}

// AddRepetitionCount adds i to the "repetition_count" field.
func (m *QuestionReviewMutation) AddRepetitionCount(i int) {
	if m.addrepetition_count != nil {
		*m.addrepetition_count += i
	} else {
		m.addrepetition_count = &i
	}
}

// AddedRepetitionCount returns the value that was added to the "repetition_count" field in this mutation.
func (m *QuestionReviewMutation) AddedRepetitionCount() (r int, exists bool) {
	v := m.addrepetition_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRepetitionCount resets all changes to the "repetition_count" field.
func (m *QuestionReviewMutation) ResetRepetitionCount() {
	m.repetition_count = nil
	m.addrepetition_count = nil
}

// SetNextReviewDate sets the "next_review_date" field.
func (m *QuestionReviewMutation) SetNextReviewDate(t time.Time) {
	m.next_review_date = &t
}

// NextReviewDate returns the value of the "next_review_date" field in the mutation.
func (m *QuestionReviewMutation) NextReviewDate() (r time.Time, exists bool) {
	v := m.next_review_date
	if v == nil {
		return
	}
	return *v, true
}

// OldNextReviewDate returns the old "next_review_date" field's value of the QuestionReview entity.
// If the QuestionReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionReviewMutation) OldNextReviewDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextReviewDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextReviewDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextReviewDate: %w", err)
	}
	return oldValue.NextReviewDate, nil
}

// ResetNextReviewDate resets all changes to the "next_review_date" field.
func (m *QuestionReviewMutation) ResetNextReviewDate() {
	m.next_review_date = nil
}

// SetLastReviewedAt sets the "last_reviewed_at" field.
func (m *QuestionReviewMutation) SetLastReviewedAt(t time.Time) {
	m.last_reviewed_at = &t
}

// LastReviewedAt returns the value of the "last_reviewed_at" field in the mutation.
func (m *QuestionReviewMutation) LastReviewedAt() (r time.Time, exists bool) {
	v := m.last_reviewed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastReviewedAt returns the old "last_reviewed_at" field's value of the QuestionReview entity.
// If the QuestionReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionReviewMutation) OldLastReviewedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastReviewedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastReviewedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastReviewedAt: %w", err)
	}
	return oldValue.LastReviewedAt, nil
}

// ClearLastReviewedAt clears the value of the "last_reviewed_at" field.
func (m *QuestionReviewMutation) ClearLastReviewedAt() {
	m.last_reviewed_at = nil
	m.clearedFields[questionreview.FieldLastReviewedAt] = struct{}{}
}

// LastReviewedAtCleared returns if the "last_reviewed_at" field was cleared in this mutation.
func (m *QuestionReviewMutation) LastReviewedAtCleared() bool {
	_, ok := m.clearedFields[questionreview.FieldLastReviewedAt]
	return ok
}

// ResetLastReviewedAt resets all changes to the "last_reviewed_at" field.
func (m *QuestionReviewMutation) ResetLastReviewedAt() {
	m.last_reviewed_at = nil
	delete(m.clearedFields, questionreview.FieldLastReviewedAt)
}

// SetIsDue sets the "is_due" field.
func (m *QuestionReviewMutation) SetIsDue(b bool) {
	m.is_due = &b
}

// IsDue returns the value of the "is_due" field in the mutation.
func (m *QuestionReviewMutation) IsDue() (r bool, exists bool) {
	v := m.is_due
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDue returns the old "is_due" field's value of the QuestionReview entity.
// If the QuestionReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionReviewMutation) OldIsDue(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDue: %w", err)
	}
	return oldValue.IsDue, nil
}

// ResetIsDue resets all changes to the "is_due" field.
func (m *QuestionReviewMutation) ResetIsDue() {
	m.is_due = nil
}

// SetTotalAttempts sets the "total_attempts" field.
func (m *QuestionReviewMutation) SetTotalAttempts(i int) {
	m.total_attempts = &i
	m.addtotal_attempts = nil
}

// TotalAttempts returns the value of the "total_attempts" field in the mutation.
func (m *QuestionReviewMutation) TotalAttempts() (r int, exists bool) {
	v := m.total_attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAttempts returns the old "total_attempts" field's value of the QuestionReview entity.
// If the QuestionReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionReviewMutation) OldTotalAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAttempts: %w", err)
	}
	return oldValue.TotalAttempts, nil
}

// AddTotalAttempts adds i to the "total_attempts" field.
func (m *QuestionReviewMutation) AddTotalAttempts(i int) {
	if m.addtotal_attempts != nil {
		*m.addtotal_attempts += i
	} else {
		m.addtotal_attempts = &i
	}
}

// AddedTotalAttempts returns the value that was added to the "total_attempts" field in this mutation.
func (m *QuestionReviewMutation) AddedTotalAttempts() (r int, exists bool) {
	v := m.addtotal_attempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAttempts resets all changes to the "total_attempts" field.
func (m *QuestionReviewMutation) ResetTotalAttempts() {
	m.total_attempts = nil
	m.addtotal_attempts = nil
}

// SetCorrectAttempts sets the "correct_attempts" field.
func (m *QuestionReviewMutation) SetCorrectAttempts(i int) {
	m.correct_attempts = &i
	m.addcorrect_attempts = nil
}

// CorrectAttempts returns the value of the "correct_attempts" field in the mutation.
func (m *QuestionReviewMutation) CorrectAttempts() (r int, exists bool) {
	v := m.correct_attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrectAttempts returns the old "correct_attempts" field's value of the QuestionReview entity.
// If the QuestionReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionReviewMutation) OldCorrectAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrectAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrectAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrectAttempts: %w", err)
	}
	return oldValue.CorrectAttempts, nil
}

// AddCorrectAttempts adds i to the "correct_attempts" field.
func (m *QuestionReviewMutation) AddCorrectAttempts(i int) {
	if m.addcorrect_attempts != nil {
		*m.addcorrect_attempts += i
	} else {
		m.addcorrect_attempts = &i
	}
}

// AddedCorrectAttempts returns the value that was added to the "correct_attempts" field in this mutation.
func (m *QuestionReviewMutation) AddedCorrectAttempts() (r int, exists bool) {
	v := m.addcorrect_attempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetCorrectAttempts resets all changes to the "correct_attempts" field.
func (m *QuestionReviewMutation) ResetCorrectAttempts() {
	m.correct_attempts = nil
	m.addcorrect_attempts = nil
}

// SetAccuracyRate sets the "accuracy_rate" field.
func (m *QuestionReviewMutation) SetAccuracyRate(f float64) {
	m.accuracy_rate = &f
	m.addaccuracy_rate = nil
}

// AccuracyRate returns the value of the "accuracy_rate" field in the mutation.
func (m *QuestionReviewMutation) AccuracyRate() (r float64, exists bool) {
	v := m.accuracy_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldAccuracyRate returns the old "accuracy_rate" field's value of the QuestionReview entity.
// If the QuestionReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionReviewMutation) OldAccuracyRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccuracyRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccuracyRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccuracyRate: %w", err)
	}
	return oldValue.AccuracyRate, nil
}

// AddAccuracyRate adds f to the "accuracy_rate" field.
func (m *QuestionReviewMutation) AddAccuracyRate(f float64) {
	if m.addaccuracy_rate != nil {
		*m.addaccuracy_rate += f
	} else {
		m.addaccuracy_rate = &f
	}
}

// AddedAccuracyRate returns the value that was added to the "accuracy_rate" field in this mutation.
func (m *QuestionReviewMutation) AddedAccuracyRate() (r float64, exists bool) {
	v := m.addaccuracy_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccuracyRate resets all changes to the "accuracy_rate" field.
func (m *QuestionReviewMutation) ResetAccuracyRate() {
	m.accuracy_rate = nil
	m.addaccuracy_rate = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *QuestionReviewMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *QuestionReviewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the QuestionReview entity.
// If the QuestionReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionReviewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *QuestionReviewMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *QuestionReviewMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *QuestionReviewMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the QuestionReview entity.
// If the QuestionReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionReviewMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *QuestionReviewMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *QuestionReviewMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *QuestionReviewMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *QuestionReviewMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *QuestionReviewMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *QuestionReviewMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *QuestionReviewMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetQuestionID sets the "question" edge to the Question entity by id.
func (m *QuestionReviewMutation) SetQuestionID(id int) {
	m.question = &id
}

// ClearQuestion clears the "question" edge to the Question entity.
func (m *QuestionReviewMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared reports if the "question" edge to the Question entity was cleared.
func (m *QuestionReviewMutation) QuestionCleared() bool {
	return m.clearedquestion
}

// QuestionID returns the "question" edge ID in the mutation.
func (m *QuestionReviewMutation) QuestionID() (id int, exists bool) {
	if m.question != nil {
		return *m.question, true
	}
	return
}

// QuestionIDs returns the "question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *QuestionReviewMutation) QuestionIDs() (ids []int) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *QuestionReviewMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// AddQuestionAttemptIDs adds the "question_attempts" edge to the QuestionAttempt entity by ids.
func (m *QuestionReviewMutation) AddQuestionAttemptIDs(ids ...int) {
	if m.question_attempts == nil {
		m.question_attempts = make(map[int]struct{})
	}
	for i := range ids {
		m.question_attempts[ids[i]] = struct{}{}
	}
}

// ClearQuestionAttempts clears the "question_attempts" edge to the QuestionAttempt entity.
func (m *QuestionReviewMutation) ClearQuestionAttempts() {
	m.clearedquestion_attempts = true
}

// QuestionAttemptsCleared reports if the "question_attempts" edge to the QuestionAttempt entity was cleared.
func (m *QuestionReviewMutation) QuestionAttemptsCleared() bool {
	return m.clearedquestion_attempts
}

// RemoveQuestionAttemptIDs removes the "question_attempts" edge to the QuestionAttempt entity by IDs.
func (m *QuestionReviewMutation) RemoveQuestionAttemptIDs(ids ...int) {
	if m.removedquestion_attempts == nil {
		m.removedquestion_attempts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.question_attempts, ids[i])
		m.removedquestion_attempts[ids[i]] = struct{}{}
	}
}

// RemovedQuestionAttempts returns the removed IDs of the "question_attempts" edge to the QuestionAttempt entity.
func (m *QuestionReviewMutation) RemovedQuestionAttemptsIDs() (ids []int) {
	for id := range m.removedquestion_attempts {
		ids = append(ids, id)
	}
	return
}

// QuestionAttemptsIDs returns the "question_attempts" edge IDs in the mutation.
func (m *QuestionReviewMutation) QuestionAttemptsIDs() (ids []int) {
	for id := range m.question_attempts {
		ids = append(ids, id)
	}
	return
}

// ResetQuestionAttempts resets all changes to the "question_attempts" edge.
func (m *QuestionReviewMutation) ResetQuestionAttempts() {
	m.question_attempts = nil
	m.clearedquestion_attempts = false
	m.removedquestion_attempts = nil
}

// Where appends a list predicates to the QuestionReviewMutation builder.
func (m *QuestionReviewMutation) Where(ps ...predicate.QuestionReview) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QuestionReviewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QuestionReviewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.QuestionReview, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QuestionReviewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QuestionReviewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (QuestionReview).
func (m *QuestionReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QuestionReviewMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.ease_factor != nil {
		fields = append(fields, questionreview.FieldEaseFactor)
	}
	if m.interval_days != nil {
		fields = append(fields, questionreview.FieldIntervalDays)
	}
	if m.repetition_count != nil {
		fields = append(fields, questionreview.FieldRepetitionCount)
	}
	if m.next_review_date != nil {
		fields = append(fields, questionreview.FieldNextReviewDate)
	}
	if m.last_reviewed_at != nil {
		fields = append(fields, questionreview.FieldLastReviewedAt)
	}
	if m.is_due != nil {
		fields = append(fields, questionreview.FieldIsDue)
	}
	if m.total_attempts != nil {
		fields = append(fields, questionreview.FieldTotalAttempts)
	}
	if m.correct_attempts != nil {
		fields = append(fields, questionreview.FieldCorrectAttempts)
	}
	if m.accuracy_rate != nil {
		fields = append(fields, questionreview.FieldAccuracyRate)
	}
	if m.created_at != nil {
		fields = append(fields, questionreview.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, questionreview.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QuestionReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case questionreview.FieldEaseFactor:
		return m.EaseFactor()
	case questionreview.FieldIntervalDays:
		return m.IntervalDays()
	case questionreview.FieldRepetitionCount:
		return m.RepetitionCount()
	case questionreview.FieldNextReviewDate:
		return m.NextReviewDate()
	case questionreview.FieldLastReviewedAt:
		return m.LastReviewedAt()
	case questionreview.FieldIsDue:
		return m.IsDue()
	case questionreview.FieldTotalAttempts:
		return m.TotalAttempts()
	case questionreview.FieldCorrectAttempts:
		return m.CorrectAttempts()
	case questionreview.FieldAccuracyRate:
		return m.AccuracyRate()
	case questionreview.FieldCreatedAt:
		return m.CreatedAt()
	case questionreview.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QuestionReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case questionreview.FieldEaseFactor:
		return m.OldEaseFactor(ctx)
	case questionreview.FieldIntervalDays:
		return m.OldIntervalDays(ctx)
	case questionreview.FieldRepetitionCount:
		return m.OldRepetitionCount(ctx)
	case questionreview.FieldNextReviewDate:
		return m.OldNextReviewDate(ctx)
	case questionreview.FieldLastReviewedAt:
		return m.OldLastReviewedAt(ctx)
	case questionreview.FieldIsDue:
		return m.OldIsDue(ctx)
	case questionreview.FieldTotalAttempts:
		return m.OldTotalAttempts(ctx)
	case questionreview.FieldCorrectAttempts:
		return m.OldCorrectAttempts(ctx)
	case questionreview.FieldAccuracyRate:
		return m.OldAccuracyRate(ctx)
	case questionreview.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case questionreview.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown QuestionReview field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case questionreview.FieldEaseFactor:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEaseFactor(v)
		return nil
	case questionreview.FieldIntervalDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntervalDays(v)
		return nil
	case questionreview.FieldRepetitionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepetitionCount(v)
		return nil
	case questionreview.FieldNextReviewDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextReviewDate(v)
		return nil
	case questionreview.FieldLastReviewedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastReviewedAt(v)
		return nil
	case questionreview.FieldIsDue:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDue(v)
		return nil
	case questionreview.FieldTotalAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAttempts(v)
		return nil
	case questionreview.FieldCorrectAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrectAttempts(v)
		return nil
	case questionreview.FieldAccuracyRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccuracyRate(v)
		return nil
	case questionreview.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case questionreview.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown QuestionReview field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QuestionReviewMutation) AddedFields() []string {
	var fields []string
	if m.addease_factor != nil {
		fields = append(fields, questionreview.FieldEaseFactor)
	}
	if m.addinterval_days != nil {
		fields = append(fields, questionreview.FieldIntervalDays)
	}
	if m.addrepetition_count != nil {
		fields = append(fields, questionreview.FieldRepetitionCount)
	}
	if m.addtotal_attempts != nil {
		fields = append(fields, questionreview.FieldTotalAttempts)
	}
	if m.addcorrect_attempts != nil {
		fields = append(fields, questionreview.FieldCorrectAttempts)
	}
	if m.addaccuracy_rate != nil {
		fields = append(fields, questionreview.FieldAccuracyRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QuestionReviewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case questionreview.FieldEaseFactor:
		return m.AddedEaseFactor()
	case questionreview.FieldIntervalDays:
		return m.AddedIntervalDays()
	case questionreview.FieldRepetitionCount:
		return m.AddedRepetitionCount()
	case questionreview.FieldTotalAttempts:
		return m.AddedTotalAttempts()
	case questionreview.FieldCorrectAttempts:
		return m.AddedCorrectAttempts()
	case questionreview.FieldAccuracyRate:
		return m.AddedAccuracyRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case questionreview.FieldEaseFactor:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEaseFactor(v)
		return nil
	case questionreview.FieldIntervalDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntervalDays(v)
		return nil
	case questionreview.FieldRepetitionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepetitionCount(v)
		return nil
	case questionreview.FieldTotalAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAttempts(v)
		return nil
	case questionreview.FieldCorrectAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCorrectAttempts(v)
		return nil
	case questionreview.FieldAccuracyRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccuracyRate(v)
		return nil
	}
	return fmt.Errorf("unknown QuestionReview numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QuestionReviewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(questionreview.FieldLastReviewedAt) {
		fields = append(fields, questionreview.FieldLastReviewedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QuestionReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QuestionReviewMutation) ClearField(name string) error {
	switch name {
	case questionreview.FieldLastReviewedAt:
		m.ClearLastReviewedAt()
		return nil
	}
	return fmt.Errorf("unknown QuestionReview nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QuestionReviewMutation) ResetField(name string) error {
	switch name {
	case questionreview.FieldEaseFactor:
		m.ResetEaseFactor()
		return nil
	case questionreview.FieldIntervalDays:
		m.ResetIntervalDays()
		return nil
	case questionreview.FieldRepetitionCount:
		m.ResetRepetitionCount()
		return nil
	case questionreview.FieldNextReviewDate:
		m.ResetNextReviewDate()
		return nil
	case questionreview.FieldLastReviewedAt:
		m.ResetLastReviewedAt()
		return nil
	case questionreview.FieldIsDue:
		m.ResetIsDue()
		return nil
	case questionreview.FieldTotalAttempts:
		m.ResetTotalAttempts()
		return nil
	case questionreview.FieldCorrectAttempts:
		m.ResetCorrectAttempts()
		return nil
	case questionreview.FieldAccuracyRate:
		m.ResetAccuracyRate()
		return nil
	case questionreview.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case questionreview.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown QuestionReview field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QuestionReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, questionreview.EdgeUser)
	}
	if m.question != nil {
		edges = append(edges, questionreview.EdgeQuestion)
	}
	if m.question_attempts != nil {
		edges = append(edges, questionreview.EdgeQuestionAttempts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QuestionReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case questionreview.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case questionreview.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	case questionreview.EdgeQuestionAttempts:
		ids := make([]ent.Value, 0, len(m.question_attempts))
		for id := range m.question_attempts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QuestionReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedquestion_attempts != nil {
		edges = append(edges, questionreview.EdgeQuestionAttempts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QuestionReviewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case questionreview.EdgeQuestionAttempts:
		ids := make([]ent.Value, 0, len(m.removedquestion_attempts))
		for id := range m.removedquestion_attempts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QuestionReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, questionreview.EdgeUser)
	}
	if m.clearedquestion {
		edges = append(edges, questionreview.EdgeQuestion)
	}
	if m.clearedquestion_attempts {
		edges = append(edges, questionreview.EdgeQuestionAttempts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QuestionReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case questionreview.EdgeUser:
		return m.cleareduser
	case questionreview.EdgeQuestion:
		return m.clearedquestion
	case questionreview.EdgeQuestionAttempts:
		return m.clearedquestion_attempts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QuestionReviewMutation) ClearEdge(name string) error {
	switch name {
	case questionreview.EdgeUser:
		m.ClearUser()
		return nil
	case questionreview.EdgeQuestion:
		m.ClearQuestion()
		return nil
	}
	return fmt.Errorf("unknown QuestionReview unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QuestionReviewMutation) ResetEdge(name string) error {
	switch name {
	case questionreview.EdgeUser:
		m.ResetUser()
		return nil
	case questionreview.EdgeQuestion:
		m.ResetQuestion()
		return nil
	case questionreview.EdgeQuestionAttempts:
		m.ResetQuestionAttempts()
		return nil
	}
	return fmt.Errorf("unknown QuestionReview edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	email                         *string
	password_hash                 *string
	username                      *string
	first_name                    *string
	last_name                     *string
	current_level                 *string
	target_level                  *string
	daily_goal                    *int
	adddaily_goal                 *int
	timezone                      *string
	last_active_at                *time.Time
	is_active                     *bool
	created_at                    *time.Time
	updated_at                    *time.Time
	clearedFields                 map[string]struct{}
	decks                         map[int]struct{}
	removeddecks                  map[int]struct{}
	cleareddecks                  bool
	question_reviews              map[int]struct{}
	removedquestion_reviews       map[int]struct{}
	clearedquestion_reviews       bool
	question_attempts             map[int]struct{}
	removedquestion_attempts      map[int]struct{}
	clearedquestion_attempts      bool
	pronunciation_attempts        map[int]struct{}
	removedpronunciation_attempts map[int]struct{}
	clearedpronunciation_attempts bool
	user_stats                    map[int]struct{}
	removeduser_stats             map[int]struct{}
	cleareduser_stats             bool
	learning_streaks              map[int]struct{}
	removedlearning_streaks       map[int]struct{}
	clearedlearning_streaks       bool
	done                          bool
	oldValue                      func(context.Context) (*User, error)
	predicates                    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetCurrentLevel sets the "current_level" field.
func (m *UserMutation) SetCurrentLevel(s string) {
	m.current_level = &s
}

// CurrentLevel returns the value of the "current_level" field in the mutation.
func (m *UserMutation) CurrentLevel() (r string, exists bool) {
	v := m.current_level
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentLevel returns the old "current_level" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCurrentLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentLevel: %w", err)
	}
	return oldValue.CurrentLevel, nil
}

// ClearCurrentLevel clears the value of the "current_level" field.
func (m *UserMutation) ClearCurrentLevel() {
	m.current_level = nil
	m.clearedFields[user.FieldCurrentLevel] = struct{}{}
}

// CurrentLevelCleared returns if the "current_level" field was cleared in this mutation.
func (m *UserMutation) CurrentLevelCleared() bool {
	_, ok := m.clearedFields[user.FieldCurrentLevel]
	return ok
}

// ResetCurrentLevel resets all changes to the "current_level" field.
func (m *UserMutation) ResetCurrentLevel() {
	m.current_level = nil
	delete(m.clearedFields, user.FieldCurrentLevel)
}

// SetTargetLevel sets the "target_level" field.
func (m *UserMutation) SetTargetLevel(s string) {
	m.target_level = &s
}

// TargetLevel returns the value of the "target_level" field in the mutation.
func (m *UserMutation) TargetLevel() (r string, exists bool) {
	v := m.target_level
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetLevel returns the old "target_level" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTargetLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetLevel: %w", err)
	}
	return oldValue.TargetLevel, nil
}

// ClearTargetLevel clears the value of the "target_level" field.
func (m *UserMutation) ClearTargetLevel() {
	m.target_level = nil
	m.clearedFields[user.FieldTargetLevel] = struct{}{}
}

// TargetLevelCleared returns if the "target_level" field was cleared in this mutation.
func (m *UserMutation) TargetLevelCleared() bool {
	_, ok := m.clearedFields[user.FieldTargetLevel]
	return ok
}

// ResetTargetLevel resets all changes to the "target_level" field.
func (m *UserMutation) ResetTargetLevel() {
	m.target_level = nil
	delete(m.clearedFields, user.FieldTargetLevel)
}

// SetDailyGoal sets the "daily_goal" field.
func (m *UserMutation) SetDailyGoal(i int) {
	m.daily_goal = &i
	m.adddaily_goal = nil
}

// DailyGoal returns the value of the "daily_goal" field in the mutation.
func (m *UserMutation) DailyGoal() (r int, exists bool) {
	v := m.daily_goal
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyGoal returns the old "daily_goal" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDailyGoal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDailyGoal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDailyGoal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyGoal: %w", err)
	}
	return oldValue.DailyGoal, nil
}

// AddDailyGoal adds i to the "daily_goal" field.
func (m *UserMutation) AddDailyGoal(i int) {
	if m.adddaily_goal != nil {
		*m.adddaily_goal += i
	} else {
		m.adddaily_goal = &i
	}
}

// AddedDailyGoal returns the value that was added to the "daily_goal" field in this mutation.
func (m *UserMutation) AddedDailyGoal() (r int, exists bool) {
	v := m.adddaily_goal
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyGoal resets all changes to the "daily_goal" field.
func (m *UserMutation) ResetDailyGoal() {
	m.daily_goal = nil
	m.adddaily_goal = nil
}

// SetTimezone sets the "timezone" field.
func (m *UserMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *UserMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *UserMutation) ResetTimezone() {
	m.timezone = nil
}

// SetLastActiveAt sets the "last_active_at" field.
func (m *UserMutation) SetLastActiveAt(t time.Time) {
	m.last_active_at = &t
}

// LastActiveAt returns the value of the "last_active_at" field in the mutation.
func (m *UserMutation) LastActiveAt() (r time.Time, exists bool) {
	v := m.last_active_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActiveAt returns the old "last_active_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastActiveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActiveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActiveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActiveAt: %w", err)
	}
	return oldValue.LastActiveAt, nil
}

// ClearLastActiveAt clears the value of the "last_active_at" field.
func (m *UserMutation) ClearLastActiveAt() {
	m.last_active_at = nil
	m.clearedFields[user.FieldLastActiveAt] = struct{}{}
}

// LastActiveAtCleared returns if the "last_active_at" field was cleared in this mutation.
func (m *UserMutation) LastActiveAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastActiveAt]
	return ok
}

// ResetLastActiveAt resets all changes to the "last_active_at" field.
func (m *UserMutation) ResetLastActiveAt() {
	m.last_active_at = nil
	delete(m.clearedFields, user.FieldLastActiveAt)
}

// SetIsActive sets the "is_active" field.
func (m *UserMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddDeckIDs adds the "decks" edge to the Deck entity by ids.
func (m *UserMutation) AddDeckIDs(ids ...int) {
	if m.decks == nil {
		m.decks = make(map[int]struct{})
	}
	for i := range ids {
		m.decks[ids[i]] = struct{}{}
	}
}

// ClearDecks clears the "decks" edge to the Deck entity.
func (m *UserMutation) ClearDecks() {
	m.cleareddecks = true
}

// DecksCleared reports if the "decks" edge to the Deck entity was cleared.
func (m *UserMutation) DecksCleared() bool {
	return m.cleareddecks
}

// RemoveDeckIDs removes the "decks" edge to the Deck entity by IDs.
func (m *UserMutation) RemoveDeckIDs(ids ...int) {
	if m.removeddecks == nil {
		m.removeddecks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.decks, ids[i])
		m.removeddecks[ids[i]] = struct{}{}
	}
}

// RemovedDecks returns the removed IDs of the "decks" edge to the Deck entity.
func (m *UserMutation) RemovedDecksIDs() (ids []int) {
	for id := range m.removeddecks {
		ids = append(ids, id)
	}
	return
}

// DecksIDs returns the "decks" edge IDs in the mutation.
func (m *UserMutation) DecksIDs() (ids []int) {
	for id := range m.decks {
		ids = append(ids, id)
	}
	return
}

// ResetDecks resets all changes to the "decks" edge.
func (m *UserMutation) ResetDecks() {
	m.decks = nil
	m.cleareddecks = false
	m.removeddecks = nil
}

// AddQuestionReviewIDs adds the "question_reviews" edge to the QuestionReview entity by ids.
func (m *UserMutation) AddQuestionReviewIDs(ids ...int) {
	if m.question_reviews == nil {
		m.question_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.question_reviews[ids[i]] = struct{}{}
	}
}

// ClearQuestionReviews clears the "question_reviews" edge to the QuestionReview entity.
func (m *UserMutation) ClearQuestionReviews() {
	m.clearedquestion_reviews = true
}

// QuestionReviewsCleared reports if the "question_reviews" edge to the QuestionReview entity was cleared.
func (m *UserMutation) QuestionReviewsCleared() bool {
	return m.clearedquestion_reviews
}

// RemoveQuestionReviewIDs removes the "question_reviews" edge to the QuestionReview entity by IDs.
func (m *UserMutation) RemoveQuestionReviewIDs(ids ...int) {
	if m.removedquestion_reviews == nil {
		m.removedquestion_reviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.question_reviews, ids[i])
		m.removedquestion_reviews[ids[i]] = struct{}{}
	}
}

// RemovedQuestionReviews returns the removed IDs of the "question_reviews" edge to the QuestionReview entity.
func (m *UserMutation) RemovedQuestionReviewsIDs() (ids []int) {
	for id := range m.removedquestion_reviews {
		ids = append(ids, id)
	}
	return
}

// QuestionReviewsIDs returns the "question_reviews" edge IDs in the mutation.
func (m *UserMutation) QuestionReviewsIDs() (ids []int) {
	for id := range m.question_reviews {
		ids = append(ids, id)
	}
	return
}

// ResetQuestionReviews resets all changes to the "question_reviews" edge.
func (m *UserMutation) ResetQuestionReviews() {
	m.question_reviews = nil
	m.clearedquestion_reviews = false
	m.removedquestion_reviews = nil
}

// AddQuestionAttemptIDs adds the "question_attempts" edge to the QuestionAttempt entity by ids.
func (m *UserMutation) AddQuestionAttemptIDs(ids ...int) {
	if m.question_attempts == nil {
		m.question_attempts = make(map[int]struct{})
	}
	for i := range ids {
		m.question_attempts[ids[i]] = struct{}{}
	}
}

// ClearQuestionAttempts clears the "question_attempts" edge to the QuestionAttempt entity.
func (m *UserMutation) ClearQuestionAttempts() {
	m.clearedquestion_attempts = true
}

// QuestionAttemptsCleared reports if the "question_attempts" edge to the QuestionAttempt entity was cleared.
func (m *UserMutation) QuestionAttemptsCleared() bool {
	return m.clearedquestion_attempts
}

// RemoveQuestionAttemptIDs removes the "question_attempts" edge to the QuestionAttempt entity by IDs.
func (m *UserMutation) RemoveQuestionAttemptIDs(ids ...int) {
	if m.removedquestion_attempts == nil {
		m.removedquestion_attempts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.question_attempts, ids[i])
		m.removedquestion_attempts[ids[i]] = struct{}{}
	}
}

// RemovedQuestionAttempts returns the removed IDs of the "question_attempts" edge to the QuestionAttempt entity.
func (m *UserMutation) RemovedQuestionAttemptsIDs() (ids []int) {
	for id := range m.removedquestion_attempts {
		ids = append(ids, id)
	}
	return
}

// QuestionAttemptsIDs returns the "question_attempts" edge IDs in the mutation.
func (m *UserMutation) QuestionAttemptsIDs() (ids []int) {
	for id := range m.question_attempts {
		ids = append(ids, id)
	}
	return
}

// ResetQuestionAttempts resets all changes to the "question_attempts" edge.
func (m *UserMutation) ResetQuestionAttempts() {
	m.question_attempts = nil
	m.clearedquestion_attempts = false
	m.removedquestion_attempts = nil
}

// AddPronunciationAttemptIDs adds the "pronunciation_attempts" edge to the PronunciationAttempt entity by ids.
func (m *UserMutation) AddPronunciationAttemptIDs(ids ...int) {
	if m.pronunciation_attempts == nil {
		m.pronunciation_attempts = make(map[int]struct{})
	}
	for i := range ids {
		m.pronunciation_attempts[ids[i]] = struct{}{}
	}
}

// ClearPronunciationAttempts clears the "pronunciation_attempts" edge to the PronunciationAttempt entity.
func (m *UserMutation) ClearPronunciationAttempts() {
	m.clearedpronunciation_attempts = true
}

// PronunciationAttemptsCleared reports if the "pronunciation_attempts" edge to the PronunciationAttempt entity was cleared.
func (m *UserMutation) PronunciationAttemptsCleared() bool {
	return m.clearedpronunciation_attempts
}

// RemovePronunciationAttemptIDs removes the "pronunciation_attempts" edge to the PronunciationAttempt entity by IDs.
func (m *UserMutation) RemovePronunciationAttemptIDs(ids ...int) {
	if m.removedpronunciation_attempts == nil {
		m.removedpronunciation_attempts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pronunciation_attempts, ids[i])
		m.removedpronunciation_attempts[ids[i]] = struct{}{}
	}
}

// RemovedPronunciationAttempts returns the removed IDs of the "pronunciation_attempts" edge to the PronunciationAttempt entity.
func (m *UserMutation) RemovedPronunciationAttemptsIDs() (ids []int) {
	for id := range m.removedpronunciation_attempts {
		ids = append(ids, id)
	}
	return
}

// PronunciationAttemptsIDs returns the "pronunciation_attempts" edge IDs in the mutation.
func (m *UserMutation) PronunciationAttemptsIDs() (ids []int) {
	for id := range m.pronunciation_attempts {
		ids = append(ids, id)
	}
	return
}

// ResetPronunciationAttempts resets all changes to the "pronunciation_attempts" edge.
func (m *UserMutation) ResetPronunciationAttempts() {
	m.pronunciation_attempts = nil
	m.clearedpronunciation_attempts = false
	m.removedpronunciation_attempts = nil
}

// AddUserStatIDs adds the "user_stats" edge to the UserStats entity by ids.
func (m *UserMutation) AddUserStatIDs(ids ...int) {
	if m.user_stats == nil {
		m.user_stats = make(map[int]struct{})
	}
	for i := range ids {
		m.user_stats[ids[i]] = struct{}{}
	}
}

// ClearUserStats clears the "user_stats" edge to the UserStats entity.
func (m *UserMutation) ClearUserStats() {
	m.cleareduser_stats = true
}

// UserStatsCleared reports if the "user_stats" edge to the UserStats entity was cleared.
func (m *UserMutation) UserStatsCleared() bool {
	return m.cleareduser_stats
}

// RemoveUserStatIDs removes the "user_stats" edge to the UserStats entity by IDs.
func (m *UserMutation) RemoveUserStatIDs(ids ...int) {
	if m.removeduser_stats == nil {
		m.removeduser_stats = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_stats, ids[i])
		m.removeduser_stats[ids[i]] = struct{}{}
	}
}

// RemovedUserStats returns the removed IDs of the "user_stats" edge to the UserStats entity.
func (m *UserMutation) RemovedUserStatsIDs() (ids []int) {
	for id := range m.removeduser_stats {
		ids = append(ids, id)
	}
	return
}

// UserStatsIDs returns the "user_stats" edge IDs in the mutation.
func (m *UserMutation) UserStatsIDs() (ids []int) {
	for id := range m.user_stats {
		ids = append(ids, id)
	}
	return
}

// ResetUserStats resets all changes to the "user_stats" edge.
func (m *UserMutation) ResetUserStats() {
	m.user_stats = nil
	m.cleareduser_stats = false
	m.removeduser_stats = nil
}

// AddLearningStreakIDs adds the "learning_streaks" edge to the LearningStreak entity by ids.
func (m *UserMutation) AddLearningStreakIDs(ids ...int) {
	if m.learning_streaks == nil {
		m.learning_streaks = make(map[int]struct{})
	}
	for i := range ids {
		m.learning_streaks[ids[i]] = struct{}{}
	}
}

// ClearLearningStreaks clears the "learning_streaks" edge to the LearningStreak entity.
func (m *UserMutation) ClearLearningStreaks() {
	m.clearedlearning_streaks = true
}

// LearningStreaksCleared reports if the "learning_streaks" edge to the LearningStreak entity was cleared.
func (m *UserMutation) LearningStreaksCleared() bool {
	return m.clearedlearning_streaks
}

// RemoveLearningStreakIDs removes the "learning_streaks" edge to the LearningStreak entity by IDs.
func (m *UserMutation) RemoveLearningStreakIDs(ids ...int) {
	if m.removedlearning_streaks == nil {
		m.removedlearning_streaks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.learning_streaks, ids[i])
		m.removedlearning_streaks[ids[i]] = struct{}{}
	}
}

// RemovedLearningStreaks returns the removed IDs of the "learning_streaks" edge to the LearningStreak entity.
func (m *UserMutation) RemovedLearningStreaksIDs() (ids []int) {
	for id := range m.removedlearning_streaks {
		ids = append(ids, id)
	}
	return
}

// LearningStreaksIDs returns the "learning_streaks" edge IDs in the mutation.
func (m *UserMutation) LearningStreaksIDs() (ids []int) {
	for id := range m.learning_streaks {
		ids = append(ids, id)
	}
	return
}

// ResetLearningStreaks resets all changes to the "learning_streaks" edge.
func (m *UserMutation) ResetLearningStreaks() {
	m.learning_streaks = nil
	m.clearedlearning_streaks = false
	m.removedlearning_streaks = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.current_level != nil {
		fields = append(fields, user.FieldCurrentLevel)
	}
	if m.target_level != nil {
		fields = append(fields, user.FieldTargetLevel)
	}
	if m.daily_goal != nil {
		fields = append(fields, user.FieldDailyGoal)
	}
	if m.timezone != nil {
		fields = append(fields, user.FieldTimezone)
	}
	if m.last_active_at != nil {
		fields = append(fields, user.FieldLastActiveAt)
	}
	if m.is_active != nil {
		fields = append(fields, user.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldUsername:
		return m.Username()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldCurrentLevel:
		return m.CurrentLevel()
	case user.FieldTargetLevel:
		return m.TargetLevel()
	case user.FieldDailyGoal:
		return m.DailyGoal()
	case user.FieldTimezone:
		return m.Timezone()
	case user.FieldLastActiveAt:
		return m.LastActiveAt()
	case user.FieldIsActive:
		return m.IsActive()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldCurrentLevel:
		return m.OldCurrentLevel(ctx)
	case user.FieldTargetLevel:
		return m.OldTargetLevel(ctx)
	case user.FieldDailyGoal:
		return m.OldDailyGoal(ctx)
	case user.FieldTimezone:
		return m.OldTimezone(ctx)
	case user.FieldLastActiveAt:
		return m.OldLastActiveAt(ctx)
	case user.FieldIsActive:
		return m.OldIsActive(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldCurrentLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentLevel(v)
		return nil
	case user.FieldTargetLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetLevel(v)
		return nil
	case user.FieldDailyGoal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyGoal(v)
		return nil
	case user.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case user.FieldLastActiveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActiveAt(v)
		return nil
	case user.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.adddaily_goal != nil {
		fields = append(fields, user.FieldDailyGoal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDailyGoal:
		return m.AddedDailyGoal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldDailyGoal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyGoal(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldCurrentLevel) {
		fields = append(fields, user.FieldCurrentLevel)
	}
	if m.FieldCleared(user.FieldTargetLevel) {
		fields = append(fields, user.FieldTargetLevel)
	}
	if m.FieldCleared(user.FieldLastActiveAt) {
		fields = append(fields, user.FieldLastActiveAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldCurrentLevel:
		m.ClearCurrentLevel()
		return nil
	case user.FieldTargetLevel:
		m.ClearTargetLevel()
		return nil
	case user.FieldLastActiveAt:
		m.ClearLastActiveAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldCurrentLevel:
		m.ResetCurrentLevel()
		return nil
	case user.FieldTargetLevel:
		m.ResetTargetLevel()
		return nil
	case user.FieldDailyGoal:
		m.ResetDailyGoal()
		return nil
	case user.FieldTimezone:
		m.ResetTimezone()
		return nil
	case user.FieldLastActiveAt:
		m.ResetLastActiveAt()
		return nil
	case user.FieldIsActive:
		m.ResetIsActive()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.decks != nil {
		edges = append(edges, user.EdgeDecks)
	}
	if m.question_reviews != nil {
		edges = append(edges, user.EdgeQuestionReviews)
	}
	if m.question_attempts != nil {
		edges = append(edges, user.EdgeQuestionAttempts)
	}
	if m.pronunciation_attempts != nil {
		edges = append(edges, user.EdgePronunciationAttempts)
	}
	if m.user_stats != nil {
		edges = append(edges, user.EdgeUserStats)
	}
	if m.learning_streaks != nil {
		edges = append(edges, user.EdgeLearningStreaks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDecks:
		ids := make([]ent.Value, 0, len(m.decks))
		for id := range m.decks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeQuestionReviews:
		ids := make([]ent.Value, 0, len(m.question_reviews))
		for id := range m.question_reviews {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeQuestionAttempts:
		ids := make([]ent.Value, 0, len(m.question_attempts))
		for id := range m.question_attempts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePronunciationAttempts:
		ids := make([]ent.Value, 0, len(m.pronunciation_attempts))
		for id := range m.pronunciation_attempts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserStats:
		ids := make([]ent.Value, 0, len(m.user_stats))
		for id := range m.user_stats {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLearningStreaks:
		ids := make([]ent.Value, 0, len(m.learning_streaks))
		for id := range m.learning_streaks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removeddecks != nil {
		edges = append(edges, user.EdgeDecks)
	}
	if m.removedquestion_reviews != nil {
		edges = append(edges, user.EdgeQuestionReviews)
	}
	if m.removedquestion_attempts != nil {
		edges = append(edges, user.EdgeQuestionAttempts)
	}
	if m.removedpronunciation_attempts != nil {
		edges = append(edges, user.EdgePronunciationAttempts)
	}
	if m.removeduser_stats != nil {
		edges = append(edges, user.EdgeUserStats)
	}
	if m.removedlearning_streaks != nil {
		edges = append(edges, user.EdgeLearningStreaks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDecks:
		ids := make([]ent.Value, 0, len(m.removeddecks))
		for id := range m.removeddecks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeQuestionReviews:
		ids := make([]ent.Value, 0, len(m.removedquestion_reviews))
		for id := range m.removedquestion_reviews {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeQuestionAttempts:
		ids := make([]ent.Value, 0, len(m.removedquestion_attempts))
		for id := range m.removedquestion_attempts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePronunciationAttempts:
		ids := make([]ent.Value, 0, len(m.removedpronunciation_attempts))
		for id := range m.removedpronunciation_attempts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserStats:
		ids := make([]ent.Value, 0, len(m.removeduser_stats))
		for id := range m.removeduser_stats {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLearningStreaks:
		ids := make([]ent.Value, 0, len(m.removedlearning_streaks))
		for id := range m.removedlearning_streaks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleareddecks {
		edges = append(edges, user.EdgeDecks)
	}
	if m.clearedquestion_reviews {
		edges = append(edges, user.EdgeQuestionReviews)
	}
	if m.clearedquestion_attempts {
		edges = append(edges, user.EdgeQuestionAttempts)
	}
	if m.clearedpronunciation_attempts {
		edges = append(edges, user.EdgePronunciationAttempts)
	}
	if m.cleareduser_stats {
		edges = append(edges, user.EdgeUserStats)
	}
	if m.clearedlearning_streaks {
		edges = append(edges, user.EdgeLearningStreaks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeDecks:
		return m.cleareddecks
	case user.EdgeQuestionReviews:
		return m.clearedquestion_reviews
	case user.EdgeQuestionAttempts:
		return m.clearedquestion_attempts
	case user.EdgePronunciationAttempts:
		return m.clearedpronunciation_attempts
	case user.EdgeUserStats:
		return m.cleareduser_stats
	case user.EdgeLearningStreaks:
		return m.clearedlearning_streaks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeDecks:
		m.ResetDecks()
		return nil
	case user.EdgeQuestionReviews:
		m.ResetQuestionReviews()
		return nil
	case user.EdgeQuestionAttempts:
		m.ResetQuestionAttempts()
		return nil
	case user.EdgePronunciationAttempts:
		m.ResetPronunciationAttempts()
		return nil
	case user.EdgeUserStats:
		m.ResetUserStats()
		return nil
	case user.EdgeLearningStreaks:
		m.ResetLearningStreaks()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserStatsMutation represents an operation that mutates the UserStats nodes in the graph.
type UserStatsMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	stat_date                     *time.Time
	questions_answered            *int
	addquestions_answered         *int
	questions_correct             *int
	addquestions_correct          *int
	words_learned                 *int
	addwords_learned              *int
	total_study_time_minutes      *int
	addtotal_study_time_minutes   *int
	streak_days                   *int
	addstreak_days                *int
	english_to_french_accuracy    *float64
	addenglish_to_french_accuracy *float64
	french_to_english_accuracy    *float64
	addfrench_to_english_accuracy *float64
	pronunciation_accuracy        *float64
	addpronunciation_accuracy     *float64
	average_response_time_ms      *int
	addaverage_response_time_ms   *int
	words_per_minute              *float64
	addwords_per_minute           *float64
	strengths                     *[]string
	appendstrengths               []string
	weaknesses                    *[]string
	appendweaknesses              []string
	recommendations               *string
	created_at                    *time.Time
	updated_at                    *time.Time
	clearedFields                 map[string]struct{}
	user                          *int
	cleareduser                   bool
	done                          bool
	oldValue                      func(context.Context) (*UserStats, error)
	predicates                    []predicate.UserStats
}

var _ ent.Mutation = (*UserStatsMutation)(nil)

// userstatsOption allows management of the mutation configuration using functional options.
type userstatsOption func(*UserStatsMutation)

// newUserStatsMutation creates new mutation for the UserStats entity.
func newUserStatsMutation(c config, op Op, opts ...userstatsOption) *UserStatsMutation {
	m := &UserStatsMutation{
		config:        c,
		op:            op,
		typ:           TypeUserStats,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserStatsID sets the ID field of the mutation.
func withUserStatsID(id int) userstatsOption {
	return func(m *UserStatsMutation) {
		var (
			err   error
			once  sync.Once
			value *UserStats
		)
		m.oldValue = func(ctx context.Context) (*UserStats, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserStats.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserStats sets the old UserStats of the mutation.
func withUserStats(node *UserStats) userstatsOption {
	return func(m *UserStatsMutation) {
		m.oldValue = func(context.Context) (*UserStats, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserStatsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserStatsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserStatsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserStatsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserStats.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatDate sets the "stat_date" field.
func (m *UserStatsMutation) SetStatDate(t time.Time) {
	m.stat_date = &t
}

// StatDate returns the value of the "stat_date" field in the mutation.
func (m *UserStatsMutation) StatDate() (r time.Time, exists bool) {
	v := m.stat_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStatDate returns the old "stat_date" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldStatDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatDate: %w", err)
	}
	return oldValue.StatDate, nil
}

// ResetStatDate resets all changes to the "stat_date" field.
func (m *UserStatsMutation) ResetStatDate() {
	m.stat_date = nil
}

// SetQuestionsAnswered sets the "questions_answered" field.
func (m *UserStatsMutation) SetQuestionsAnswered(i int) {
	m.questions_answered = &i
	m.addquestions_answered = nil
}

// QuestionsAnswered returns the value of the "questions_answered" field in the mutation.
func (m *UserStatsMutation) QuestionsAnswered() (r int, exists bool) {
	v := m.questions_answered
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionsAnswered returns the old "questions_answered" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldQuestionsAnswered(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionsAnswered is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionsAnswered requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionsAnswered: %w", err)
	}
	return oldValue.QuestionsAnswered, nil
}

// AddQuestionsAnswered adds i to the "questions_answered" field.
func (m *UserStatsMutation) AddQuestionsAnswered(i int) {
	if m.addquestions_answered != nil {
		*m.addquestions_answered += i
	} else {
		m.addquestions_answered = &i
	}
}

// AddedQuestionsAnswered returns the value that was added to the "questions_answered" field in this mutation.
func (m *UserStatsMutation) AddedQuestionsAnswered() (r int, exists bool) {
	v := m.addquestions_answered
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionsAnswered resets all changes to the "questions_answered" field.
func (m *UserStatsMutation) ResetQuestionsAnswered() {
	m.questions_answered = nil
	m.addquestions_answered = nil
}

// SetQuestionsCorrect sets the "questions_correct" field.
func (m *UserStatsMutation) SetQuestionsCorrect(i int) {
	m.questions_correct = &i
	m.addquestions_correct = nil
}

// QuestionsCorrect returns the value of the "questions_correct" field in the mutation.
func (m *UserStatsMutation) QuestionsCorrect() (r int, exists bool) {
	v := m.questions_correct
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionsCorrect returns the old "questions_correct" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldQuestionsCorrect(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionsCorrect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionsCorrect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionsCorrect: %w", err)
	}
	return oldValue.QuestionsCorrect, nil
}

// AddQuestionsCorrect adds i to the "questions_correct" field.
func (m *UserStatsMutation) AddQuestionsCorrect(i int) {
	if m.addquestions_correct != nil {
		*m.addquestions_correct += i
	} else {
		m.addquestions_correct = &i
	}
}

// AddedQuestionsCorrect returns the value that was added to the "questions_correct" field in this mutation.
func (m *UserStatsMutation) AddedQuestionsCorrect() (r int, exists bool) {
	v := m.addquestions_correct
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionsCorrect resets all changes to the "questions_correct" field.
func (m *UserStatsMutation) ResetQuestionsCorrect() {
	m.questions_correct = nil
	m.addquestions_correct = nil
}

// SetWordsLearned sets the "words_learned" field.
func (m *UserStatsMutation) SetWordsLearned(i int) {
	m.words_learned = &i
	m.addwords_learned = nil
}

// WordsLearned returns the value of the "words_learned" field in the mutation.
func (m *UserStatsMutation) WordsLearned() (r int, exists bool) {
	v := m.words_learned
	if v == nil {
		return
	}
	return *v, true
}

// OldWordsLearned returns the old "words_learned" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldWordsLearned(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWordsLearned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWordsLearned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWordsLearned: %w", err)
	}
	return oldValue.WordsLearned, nil
}

// AddWordsLearned adds i to the "words_learned" field.
func (m *UserStatsMutation) AddWordsLearned(i int) {
	if m.addwords_learned != nil {
		*m.addwords_learned += i
	} else {
		m.addwords_learned = &i
	}
}

// AddedWordsLearned returns the value that was added to the "words_learned" field in this mutation.
func (m *UserStatsMutation) AddedWordsLearned() (r int, exists bool) {
	v := m.addwords_learned
	if v == nil {
		return
	}
	return *v, true
}

// ResetWordsLearned resets all changes to the "words_learned" field.
func (m *UserStatsMutation) ResetWordsLearned() {
	m.words_learned = nil
	m.addwords_learned = nil
}

// SetTotalStudyTimeMinutes sets the "total_study_time_minutes" field.
func (m *UserStatsMutation) SetTotalStudyTimeMinutes(i int) {
	m.total_study_time_minutes = &i
	m.addtotal_study_time_minutes = nil
}

// TotalStudyTimeMinutes returns the value of the "total_study_time_minutes" field in the mutation.
func (m *UserStatsMutation) TotalStudyTimeMinutes() (r int, exists bool) {
	v := m.total_study_time_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalStudyTimeMinutes returns the old "total_study_time_minutes" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldTotalStudyTimeMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalStudyTimeMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalStudyTimeMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalStudyTimeMinutes: %w", err)
	}
	return oldValue.TotalStudyTimeMinutes, nil
}

// AddTotalStudyTimeMinutes adds i to the "total_study_time_minutes" field.
func (m *UserStatsMutation) AddTotalStudyTimeMinutes(i int) {
	if m.addtotal_study_time_minutes != nil {
		*m.addtotal_study_time_minutes += i
	} else {
		m.addtotal_study_time_minutes = &i
	}
}

// AddedTotalStudyTimeMinutes returns the value that was added to the "total_study_time_minutes" field in this mutation.
func (m *UserStatsMutation) AddedTotalStudyTimeMinutes() (r int, exists bool) {
	v := m.addtotal_study_time_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalStudyTimeMinutes resets all changes to the "total_study_time_minutes" field.
func (m *UserStatsMutation) ResetTotalStudyTimeMinutes() {
	m.total_study_time_minutes = nil
	m.addtotal_study_time_minutes = nil
}

// SetStreakDays sets the "streak_days" field.
func (m *UserStatsMutation) SetStreakDays(i int) {
	m.streak_days = &i
	m.addstreak_days = nil
}

// StreakDays returns the value of the "streak_days" field in the mutation.
func (m *UserStatsMutation) StreakDays() (r int, exists bool) {
	v := m.streak_days
	if v == nil {
		return
	}
	return *v, true
}

// OldStreakDays returns the old "streak_days" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldStreakDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreakDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreakDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreakDays: %w", err)
	}
	return oldValue.StreakDays, nil
}

// AddStreakDays adds i to the "streak_days" field.
func (m *UserStatsMutation) AddStreakDays(i int) {
	if m.addstreak_days != nil {
		*m.addstreak_days += i
	} else {
		m.addstreak_days = &i
	}
}

// AddedStreakDays returns the value that was added to the "streak_days" field in this mutation.
func (m *UserStatsMutation) AddedStreakDays() (r int, exists bool) {
	v := m.addstreak_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetStreakDays resets all changes to the "streak_days" field.
func (m *UserStatsMutation) ResetStreakDays() {
	m.streak_days = nil
	m.addstreak_days = nil
}

// SetEnglishToFrenchAccuracy sets the "english_to_french_accuracy" field.
func (m *UserStatsMutation) SetEnglishToFrenchAccuracy(f float64) {
	m.english_to_french_accuracy = &f
	m.addenglish_to_french_accuracy = nil
}

// EnglishToFrenchAccuracy returns the value of the "english_to_french_accuracy" field in the mutation.
func (m *UserStatsMutation) EnglishToFrenchAccuracy() (r float64, exists bool) {
	v := m.english_to_french_accuracy
	if v == nil {
		return
	}
	return *v, true
}

// OldEnglishToFrenchAccuracy returns the old "english_to_french_accuracy" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldEnglishToFrenchAccuracy(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnglishToFrenchAccuracy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnglishToFrenchAccuracy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnglishToFrenchAccuracy: %w", err)
	}
	return oldValue.EnglishToFrenchAccuracy, nil
}

// AddEnglishToFrenchAccuracy adds f to the "english_to_french_accuracy" field.
func (m *UserStatsMutation) AddEnglishToFrenchAccuracy(f float64) {
	if m.addenglish_to_french_accuracy != nil {
		*m.addenglish_to_french_accuracy += f
	} else {
		m.addenglish_to_french_accuracy = &f
	}
}

// AddedEnglishToFrenchAccuracy returns the value that was added to the "english_to_french_accuracy" field in this mutation.
func (m *UserStatsMutation) AddedEnglishToFrenchAccuracy() (r float64, exists bool) {
	v := m.addenglish_to_french_accuracy
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnglishToFrenchAccuracy resets all changes to the "english_to_french_accuracy" field.
func (m *UserStatsMutation) ResetEnglishToFrenchAccuracy() {
	m.english_to_french_accuracy = nil
	m.addenglish_to_french_accuracy = nil
}

// SetFrenchToEnglishAccuracy sets the "french_to_english_accuracy" field.
func (m *UserStatsMutation) SetFrenchToEnglishAccuracy(f float64) {
	m.french_to_english_accuracy = &f
	m.addfrench_to_english_accuracy = nil
}

// FrenchToEnglishAccuracy returns the value of the "french_to_english_accuracy" field in the mutation.
func (m *UserStatsMutation) FrenchToEnglishAccuracy() (r float64, exists bool) {
	v := m.french_to_english_accuracy
	if v == nil {
		return
	}
	return *v, true
}

// OldFrenchToEnglishAccuracy returns the old "french_to_english_accuracy" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldFrenchToEnglishAccuracy(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrenchToEnglishAccuracy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrenchToEnglishAccuracy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrenchToEnglishAccuracy: %w", err)
	}
	return oldValue.FrenchToEnglishAccuracy, nil
}

// AddFrenchToEnglishAccuracy adds f to the "french_to_english_accuracy" field.
func (m *UserStatsMutation) AddFrenchToEnglishAccuracy(f float64) {
	if m.addfrench_to_english_accuracy != nil {
		*m.addfrench_to_english_accuracy += f
	} else {
		m.addfrench_to_english_accuracy = &f
	}
}

// AddedFrenchToEnglishAccuracy returns the value that was added to the "french_to_english_accuracy" field in this mutation.
func (m *UserStatsMutation) AddedFrenchToEnglishAccuracy() (r float64, exists bool) {
	v := m.addfrench_to_english_accuracy
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrenchToEnglishAccuracy resets all changes to the "french_to_english_accuracy" field.
func (m *UserStatsMutation) ResetFrenchToEnglishAccuracy() {
	m.french_to_english_accuracy = nil
	m.addfrench_to_english_accuracy = nil
}

// SetPronunciationAccuracy sets the "pronunciation_accuracy" field.
func (m *UserStatsMutation) SetPronunciationAccuracy(f float64) {
	m.pronunciation_accuracy = &f
	m.addpronunciation_accuracy = nil
}

// PronunciationAccuracy returns the value of the "pronunciation_accuracy" field in the mutation.
func (m *UserStatsMutation) PronunciationAccuracy() (r float64, exists bool) {
	v := m.pronunciation_accuracy
	if v == nil {
		return
	}
	return *v, true
}

// OldPronunciationAccuracy returns the old "pronunciation_accuracy" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldPronunciationAccuracy(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPronunciationAccuracy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPronunciationAccuracy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPronunciationAccuracy: %w", err)
	}
	return oldValue.PronunciationAccuracy, nil
}

// AddPronunciationAccuracy adds f to the "pronunciation_accuracy" field.
func (m *UserStatsMutation) AddPronunciationAccuracy(f float64) {
	if m.addpronunciation_accuracy != nil {
		*m.addpronunciation_accuracy += f
	} else {
		m.addpronunciation_accuracy = &f
	}
}

// AddedPronunciationAccuracy returns the value that was added to the "pronunciation_accuracy" field in this mutation.
func (m *UserStatsMutation) AddedPronunciationAccuracy() (r float64, exists bool) {
	v := m.addpronunciation_accuracy
	if v == nil {
		return
	}
	return *v, true
}

// ResetPronunciationAccuracy resets all changes to the "pronunciation_accuracy" field.
func (m *UserStatsMutation) ResetPronunciationAccuracy() {
	m.pronunciation_accuracy = nil
	m.addpronunciation_accuracy = nil
}

// SetAverageResponseTimeMs sets the "average_response_time_ms" field.
func (m *UserStatsMutation) SetAverageResponseTimeMs(i int) {
	m.average_response_time_ms = &i
	m.addaverage_response_time_ms = nil
}

// AverageResponseTimeMs returns the value of the "average_response_time_ms" field in the mutation.
func (m *UserStatsMutation) AverageResponseTimeMs() (r int, exists bool) {
	v := m.average_response_time_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageResponseTimeMs returns the old "average_response_time_ms" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldAverageResponseTimeMs(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageResponseTimeMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageResponseTimeMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageResponseTimeMs: %w", err)
	}
	return oldValue.AverageResponseTimeMs, nil
}

// AddAverageResponseTimeMs adds i to the "average_response_time_ms" field.
func (m *UserStatsMutation) AddAverageResponseTimeMs(i int) {
	if m.addaverage_response_time_ms != nil {
		*m.addaverage_response_time_ms += i
	} else {
		m.addaverage_response_time_ms = &i
	}
}

// AddedAverageResponseTimeMs returns the value that was added to the "average_response_time_ms" field in this mutation.
func (m *UserStatsMutation) AddedAverageResponseTimeMs() (r int, exists bool) {
	v := m.addaverage_response_time_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetAverageResponseTimeMs resets all changes to the "average_response_time_ms" field.
func (m *UserStatsMutation) ResetAverageResponseTimeMs() {
	m.average_response_time_ms = nil
	m.addaverage_response_time_ms = nil
}

// SetWordsPerMinute sets the "words_per_minute" field.
func (m *UserStatsMutation) SetWordsPerMinute(f float64) {
	m.words_per_minute = &f
	m.addwords_per_minute = nil
}

// WordsPerMinute returns the value of the "words_per_minute" field in the mutation.
func (m *UserStatsMutation) WordsPerMinute() (r float64, exists bool) {
	v := m.words_per_minute
	if v == nil {
		return
	}
	return *v, true
}

// OldWordsPerMinute returns the old "words_per_minute" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldWordsPerMinute(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWordsPerMinute is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWordsPerMinute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWordsPerMinute: %w", err)
	}
	return oldValue.WordsPerMinute, nil
}

// AddWordsPerMinute adds f to the "words_per_minute" field.
func (m *UserStatsMutation) AddWordsPerMinute(f float64) {
	if m.addwords_per_minute != nil {
		*m.addwords_per_minute += f
	} else {
		m.addwords_per_minute = &f
	}
}

// AddedWordsPerMinute returns the value that was added to the "words_per_minute" field in this mutation.
func (m *UserStatsMutation) AddedWordsPerMinute() (r float64, exists bool) {
	v := m.addwords_per_minute
	if v == nil {
		return
	}
	return *v, true
}

// ResetWordsPerMinute resets all changes to the "words_per_minute" field.
func (m *UserStatsMutation) ResetWordsPerMinute() {
	m.words_per_minute = nil
	m.addwords_per_minute = nil
}

// SetStrengths sets the "strengths" field.
func (m *UserStatsMutation) SetStrengths(s []string) {
	m.strengths = &s
	m.appendstrengths = nil
}

// Strengths returns the value of the "strengths" field in the mutation.
func (m *UserStatsMutation) Strengths() (r []string, exists bool) {
	v := m.strengths
	if v == nil {
		return
	}
	return *v, true
}

// OldStrengths returns the old "strengths" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldStrengths(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrengths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrengths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrengths: %w", err)
	}
	return oldValue.Strengths, nil
}

// AppendStrengths adds s to the "strengths" field.
func (m *UserStatsMutation) AppendStrengths(s []string) {
	m.appendstrengths = append(m.appendstrengths, s...)
}

// AppendedStrengths returns the list of values that were appended to the "strengths" field in this mutation.
func (m *UserStatsMutation) AppendedStrengths() ([]string, bool) {
	if len(m.appendstrengths) == 0 {
		return nil, false
	}
	return m.appendstrengths, true
}

// ClearStrengths clears the value of the "strengths" field.
func (m *UserStatsMutation) ClearStrengths() {
	m.strengths = nil
	m.appendstrengths = nil
	m.clearedFields[userstats.FieldStrengths] = struct{}{}
}

// StrengthsCleared returns if the "strengths" field was cleared in this mutation.
func (m *UserStatsMutation) StrengthsCleared() bool {
	_, ok := m.clearedFields[userstats.FieldStrengths]
	return ok
}

// ResetStrengths resets all changes to the "strengths" field.
func (m *UserStatsMutation) ResetStrengths() {
	m.strengths = nil
	m.appendstrengths = nil
	delete(m.clearedFields, userstats.FieldStrengths)
}

// SetWeaknesses sets the "weaknesses" field.
func (m *UserStatsMutation) SetWeaknesses(s []string) {
	m.weaknesses = &s
	m.appendweaknesses = nil
}

// Weaknesses returns the value of the "weaknesses" field in the mutation.
func (m *UserStatsMutation) Weaknesses() (r []string, exists bool) {
	v := m.weaknesses
	if v == nil {
		return
	}
	return *v, true
}

// OldWeaknesses returns the old "weaknesses" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldWeaknesses(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeaknesses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeaknesses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeaknesses: %w", err)
	}
	return oldValue.Weaknesses, nil
}

// AppendWeaknesses adds s to the "weaknesses" field.
func (m *UserStatsMutation) AppendWeaknesses(s []string) {
	m.appendweaknesses = append(m.appendweaknesses, s...)
}

// AppendedWeaknesses returns the list of values that were appended to the "weaknesses" field in this mutation.
func (m *UserStatsMutation) AppendedWeaknesses() ([]string, bool) {
	if len(m.appendweaknesses) == 0 {
		return nil, false
	}
	return m.appendweaknesses, true
}

// ClearWeaknesses clears the value of the "weaknesses" field.
func (m *UserStatsMutation) ClearWeaknesses() {
	m.weaknesses = nil
	m.appendweaknesses = nil
	m.clearedFields[userstats.FieldWeaknesses] = struct{}{}
}

// WeaknessesCleared returns if the "weaknesses" field was cleared in this mutation.
func (m *UserStatsMutation) WeaknessesCleared() bool {
	_, ok := m.clearedFields[userstats.FieldWeaknesses]
	return ok
}

// ResetWeaknesses resets all changes to the "weaknesses" field.
func (m *UserStatsMutation) ResetWeaknesses() {
	m.weaknesses = nil
	m.appendweaknesses = nil
	delete(m.clearedFields, userstats.FieldWeaknesses)
}

// SetRecommendations sets the "recommendations" field.
func (m *UserStatsMutation) SetRecommendations(s string) {
	m.recommendations = &s
}

// Recommendations returns the value of the "recommendations" field in the mutation.
func (m *UserStatsMutation) Recommendations() (r string, exists bool) {
	v := m.recommendations
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommendations returns the old "recommendations" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldRecommendations(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommendations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommendations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommendations: %w", err)
	}
	return oldValue.Recommendations, nil
}

// ClearRecommendations clears the value of the "recommendations" field.
func (m *UserStatsMutation) ClearRecommendations() {
	m.recommendations = nil
	m.clearedFields[userstats.FieldRecommendations] = struct{}{}
}

// RecommendationsCleared returns if the "recommendations" field was cleared in this mutation.
func (m *UserStatsMutation) RecommendationsCleared() bool {
	_, ok := m.clearedFields[userstats.FieldRecommendations]
	return ok
}

// ResetRecommendations resets all changes to the "recommendations" field.
func (m *UserStatsMutation) ResetRecommendations() {
	m.recommendations = nil
	delete(m.clearedFields, userstats.FieldRecommendations)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserStatsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserStatsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserStatsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserStatsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserStatsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserStats entity.
// If the UserStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStatsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserStatsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserStatsMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserStatsMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserStatsMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserStatsMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserStatsMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserStatsMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserStatsMutation builder.
func (m *UserStatsMutation) Where(ps ...predicate.UserStats) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserStatsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserStatsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserStats, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserStatsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserStatsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserStats).
func (m *UserStatsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserStatsMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.stat_date != nil {
		fields = append(fields, userstats.FieldStatDate)
	}
	if m.questions_answered != nil {
		fields = append(fields, userstats.FieldQuestionsAnswered)
	}
	if m.questions_correct != nil {
		fields = append(fields, userstats.FieldQuestionsCorrect)
	}
	if m.words_learned != nil {
		fields = append(fields, userstats.FieldWordsLearned)
	}
	if m.total_study_time_minutes != nil {
		fields = append(fields, userstats.FieldTotalStudyTimeMinutes)
	}
	if m.streak_days != nil {
		fields = append(fields, userstats.FieldStreakDays)
	}
	if m.english_to_french_accuracy != nil {
		fields = append(fields, userstats.FieldEnglishToFrenchAccuracy)
	}
	if m.french_to_english_accuracy != nil {
		fields = append(fields, userstats.FieldFrenchToEnglishAccuracy)
	}
	if m.pronunciation_accuracy != nil {
		fields = append(fields, userstats.FieldPronunciationAccuracy)
	}
	if m.average_response_time_ms != nil {
		fields = append(fields, userstats.FieldAverageResponseTimeMs)
	}
	if m.words_per_minute != nil {
		fields = append(fields, userstats.FieldWordsPerMinute)
	}
	if m.strengths != nil {
		fields = append(fields, userstats.FieldStrengths)
	}
	if m.weaknesses != nil {
		fields = append(fields, userstats.FieldWeaknesses)
	}
	if m.recommendations != nil {
		fields = append(fields, userstats.FieldRecommendations)
	}
	if m.created_at != nil {
		fields = append(fields, userstats.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userstats.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserStatsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userstats.FieldStatDate:
		return m.StatDate()
	case userstats.FieldQuestionsAnswered:
		return m.QuestionsAnswered()
	case userstats.FieldQuestionsCorrect:
		return m.QuestionsCorrect()
	case userstats.FieldWordsLearned:
		return m.WordsLearned()
	case userstats.FieldTotalStudyTimeMinutes:
		return m.TotalStudyTimeMinutes()
	case userstats.FieldStreakDays:
		return m.StreakDays()
	case userstats.FieldEnglishToFrenchAccuracy:
		return m.EnglishToFrenchAccuracy()
	case userstats.FieldFrenchToEnglishAccuracy:
		return m.FrenchToEnglishAccuracy()
	case userstats.FieldPronunciationAccuracy:
		return m.PronunciationAccuracy()
	case userstats.FieldAverageResponseTimeMs:
		return m.AverageResponseTimeMs()
	case userstats.FieldWordsPerMinute:
		return m.WordsPerMinute()
	case userstats.FieldStrengths:
		return m.Strengths()
	case userstats.FieldWeaknesses:
		return m.Weaknesses()
	case userstats.FieldRecommendations:
		return m.Recommendations()
	case userstats.FieldCreatedAt:
		return m.CreatedAt()
	case userstats.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserStatsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userstats.FieldStatDate:
		return m.OldStatDate(ctx)
	case userstats.FieldQuestionsAnswered:
		return m.OldQuestionsAnswered(ctx)
	case userstats.FieldQuestionsCorrect:
		return m.OldQuestionsCorrect(ctx)
	case userstats.FieldWordsLearned:
		return m.OldWordsLearned(ctx)
	case userstats.FieldTotalStudyTimeMinutes:
		return m.OldTotalStudyTimeMinutes(ctx)
	case userstats.FieldStreakDays:
		return m.OldStreakDays(ctx)
	case userstats.FieldEnglishToFrenchAccuracy:
		return m.OldEnglishToFrenchAccuracy(ctx)
	case userstats.FieldFrenchToEnglishAccuracy:
		return m.OldFrenchToEnglishAccuracy(ctx)
	case userstats.FieldPronunciationAccuracy:
		return m.OldPronunciationAccuracy(ctx)
	case userstats.FieldAverageResponseTimeMs:
		return m.OldAverageResponseTimeMs(ctx)
	case userstats.FieldWordsPerMinute:
		return m.OldWordsPerMinute(ctx)
	case userstats.FieldStrengths:
		return m.OldStrengths(ctx)
	case userstats.FieldWeaknesses:
		return m.OldWeaknesses(ctx)
	case userstats.FieldRecommendations:
		return m.OldRecommendations(ctx)
	case userstats.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userstats.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserStats field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserStatsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userstats.FieldStatDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatDate(v)
		return nil
	case userstats.FieldQuestionsAnswered:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionsAnswered(v)
		return nil
	case userstats.FieldQuestionsCorrect:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionsCorrect(v)
		return nil
	case userstats.FieldWordsLearned:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWordsLearned(v)
		return nil
	case userstats.FieldTotalStudyTimeMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalStudyTimeMinutes(v)
		return nil
	case userstats.FieldStreakDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreakDays(v)
		return nil
	case userstats.FieldEnglishToFrenchAccuracy:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnglishToFrenchAccuracy(v)
		return nil
	case userstats.FieldFrenchToEnglishAccuracy:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrenchToEnglishAccuracy(v)
		return nil
	case userstats.FieldPronunciationAccuracy:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPronunciationAccuracy(v)
		return nil
	case userstats.FieldAverageResponseTimeMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageResponseTimeMs(v)
		return nil
	case userstats.FieldWordsPerMinute:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWordsPerMinute(v)
		return nil
	case userstats.FieldStrengths:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrengths(v)
		return nil
	case userstats.FieldWeaknesses:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeaknesses(v)
		return nil
	case userstats.FieldRecommendations:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommendations(v)
		return nil
	case userstats.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userstats.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserStats field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserStatsMutation) AddedFields() []string {
	var fields []string
	if m.addquestions_answered != nil {
		fields = append(fields, userstats.FieldQuestionsAnswered)
	}
	if m.addquestions_correct != nil {
		fields = append(fields, userstats.FieldQuestionsCorrect)
	}
	if m.addwords_learned != nil {
		fields = append(fields, userstats.FieldWordsLearned)
	}
	if m.addtotal_study_time_minutes != nil {
		fields = append(fields, userstats.FieldTotalStudyTimeMinutes)
	}
	if m.addstreak_days != nil {
		fields = append(fields, userstats.FieldStreakDays)
	}
	if m.addenglish_to_french_accuracy != nil {
		fields = append(fields, userstats.FieldEnglishToFrenchAccuracy)
	}
	if m.addfrench_to_english_accuracy != nil {
		fields = append(fields, userstats.FieldFrenchToEnglishAccuracy)
	}
	if m.addpronunciation_accuracy != nil {
		fields = append(fields, userstats.FieldPronunciationAccuracy)
	}
	if m.addaverage_response_time_ms != nil {
		fields = append(fields, userstats.FieldAverageResponseTimeMs)
	}
	if m.addwords_per_minute != nil {
		fields = append(fields, userstats.FieldWordsPerMinute)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserStatsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userstats.FieldQuestionsAnswered:
		return m.AddedQuestionsAnswered()
	case userstats.FieldQuestionsCorrect:
		return m.AddedQuestionsCorrect()
	case userstats.FieldWordsLearned:
		return m.AddedWordsLearned()
	case userstats.FieldTotalStudyTimeMinutes:
		return m.AddedTotalStudyTimeMinutes()
	case userstats.FieldStreakDays:
		return m.AddedStreakDays()
	case userstats.FieldEnglishToFrenchAccuracy:
		return m.AddedEnglishToFrenchAccuracy()
	case userstats.FieldFrenchToEnglishAccuracy:
		return m.AddedFrenchToEnglishAccuracy()
	case userstats.FieldPronunciationAccuracy:
		return m.AddedPronunciationAccuracy()
	case userstats.FieldAverageResponseTimeMs:
		return m.AddedAverageResponseTimeMs()
	case userstats.FieldWordsPerMinute:
		return m.AddedWordsPerMinute()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserStatsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userstats.FieldQuestionsAnswered:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionsAnswered(v)
		return nil
	case userstats.FieldQuestionsCorrect:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionsCorrect(v)
		return nil
	case userstats.FieldWordsLearned:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWordsLearned(v)
		return nil
	case userstats.FieldTotalStudyTimeMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalStudyTimeMinutes(v)
		return nil
	case userstats.FieldStreakDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStreakDays(v)
		return nil
	case userstats.FieldEnglishToFrenchAccuracy:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnglishToFrenchAccuracy(v)
		return nil
	case userstats.FieldFrenchToEnglishAccuracy:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrenchToEnglishAccuracy(v)
		return nil
	case userstats.FieldPronunciationAccuracy:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPronunciationAccuracy(v)
		return nil
	case userstats.FieldAverageResponseTimeMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAverageResponseTimeMs(v)
		return nil
	case userstats.FieldWordsPerMinute:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWordsPerMinute(v)
		return nil
	}
	return fmt.Errorf("unknown UserStats numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserStatsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userstats.FieldStrengths) {
		fields = append(fields, userstats.FieldStrengths)
	}
	if m.FieldCleared(userstats.FieldWeaknesses) {
		fields = append(fields, userstats.FieldWeaknesses)
	}
	if m.FieldCleared(userstats.FieldRecommendations) {
		fields = append(fields, userstats.FieldRecommendations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserStatsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserStatsMutation) ClearField(name string) error {
	switch name {
	case userstats.FieldStrengths:
		m.ClearStrengths()
		return nil
	case userstats.FieldWeaknesses:
		m.ClearWeaknesses()
		return nil
	case userstats.FieldRecommendations:
		m.ClearRecommendations()
		return nil
	}
	return fmt.Errorf("unknown UserStats nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserStatsMutation) ResetField(name string) error {
	switch name {
	case userstats.FieldStatDate:
		m.ResetStatDate()
		return nil
	case userstats.FieldQuestionsAnswered:
		m.ResetQuestionsAnswered()
		return nil
	case userstats.FieldQuestionsCorrect:
		m.ResetQuestionsCorrect()
		return nil
	case userstats.FieldWordsLearned:
		m.ResetWordsLearned()
		return nil
	case userstats.FieldTotalStudyTimeMinutes:
		m.ResetTotalStudyTimeMinutes()
		return nil
	case userstats.FieldStreakDays:
		m.ResetStreakDays()
		return nil
	case userstats.FieldEnglishToFrenchAccuracy:
		m.ResetEnglishToFrenchAccuracy()
		return nil
	case userstats.FieldFrenchToEnglishAccuracy:
		m.ResetFrenchToEnglishAccuracy()
		return nil
	case userstats.FieldPronunciationAccuracy:
		m.ResetPronunciationAccuracy()
		return nil
	case userstats.FieldAverageResponseTimeMs:
		m.ResetAverageResponseTimeMs()
		return nil
	case userstats.FieldWordsPerMinute:
		m.ResetWordsPerMinute()
		return nil
	case userstats.FieldStrengths:
		m.ResetStrengths()
		return nil
	case userstats.FieldWeaknesses:
		m.ResetWeaknesses()
		return nil
	case userstats.FieldRecommendations:
		m.ResetRecommendations()
		return nil
	case userstats.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userstats.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserStats field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserStatsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userstats.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserStatsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userstats.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserStatsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserStatsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserStatsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userstats.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserStatsMutation) EdgeCleared(name string) bool {
	switch name {
	case userstats.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserStatsMutation) ClearEdge(name string) error {
	switch name {
	case userstats.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserStats unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserStatsMutation) ResetEdge(name string) error {
	switch name {
	case userstats.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserStats edge %s", name)
}

// WordMutation represents an operation that mutates the Word nodes in the graph.
type WordMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	french_word                   *string
	english_translation           *string
	part_of_speech                *string
	gender                        *string
	french_example                *string
	english_example_translation   *string
	phonetic_transcription        *string
	pronunciation_audio_url       *string
	difficulty_level              *string
	tags                          *[]string
	appendtags                    []string
	usage_context                 *string
	is_active                     *bool
	created_at                    *time.Time
	updated_at                    *time.Time
	clearedFields                 map[string]struct{}
	deck                          *int
	cleareddeck                   bool
	questions                     map[int]struct{}
	removedquestions              map[int]struct{}
	clearedquestions              bool
	pronunciation_attempts        map[int]struct{}
	removedpronunciation_attempts map[int]struct{}
	clearedpronunciation_attempts bool
	done                          bool
	oldValue                      func(context.Context) (*Word, error)
	predicates                    []predicate.Word
}

var _ ent.Mutation = (*WordMutation)(nil)

// wordOption allows management of the mutation configuration using functional options.
type wordOption func(*WordMutation)

// newWordMutation creates new mutation for the Word entity.
func newWordMutation(c config, op Op, opts ...wordOption) *WordMutation {
	m := &WordMutation{
		config:        c,
		op:            op,
		typ:           TypeWord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWordID sets the ID field of the mutation.
func withWordID(id int) wordOption {
	return func(m *WordMutation) {
		var (
			err   error
			once  sync.Once
			value *Word
		)
		m.oldValue = func(ctx context.Context) (*Word, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Word.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWord sets the old Word of the mutation.
func withWord(node *Word) wordOption {
	return func(m *WordMutation) {
		m.oldValue = func(context.Context) (*Word, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Word.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFrenchWord sets the "french_word" field.
func (m *WordMutation) SetFrenchWord(s string) {
	m.french_word = &s
}

// FrenchWord returns the value of the "french_word" field in the mutation.
func (m *WordMutation) FrenchWord() (r string, exists bool) {
	v := m.french_word
	if v == nil {
		return
	}
	return *v, true
}

// OldFrenchWord returns the old "french_word" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldFrenchWord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrenchWord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrenchWord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrenchWord: %w", err)
	}
	return oldValue.FrenchWord, nil
}

// ResetFrenchWord resets all changes to the "french_word" field.
func (m *WordMutation) ResetFrenchWord() {
	m.french_word = nil
}

// SetEnglishTranslation sets the "english_translation" field.
func (m *WordMutation) SetEnglishTranslation(s string) {
	m.english_translation = &s
}

// EnglishTranslation returns the value of the "english_translation" field in the mutation.
func (m *WordMutation) EnglishTranslation() (r string, exists bool) {
	v := m.english_translation
	if v == nil {
		return
	}
	return *v, true
}

// OldEnglishTranslation returns the old "english_translation" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldEnglishTranslation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnglishTranslation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnglishTranslation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnglishTranslation: %w", err)
	}
	return oldValue.EnglishTranslation, nil
}

// ResetEnglishTranslation resets all changes to the "english_translation" field.
func (m *WordMutation) ResetEnglishTranslation() {
	m.english_translation = nil
}

// SetPartOfSpeech sets the "part_of_speech" field.
func (m *WordMutation) SetPartOfSpeech(s string) {
	m.part_of_speech = &s
}

// PartOfSpeech returns the value of the "part_of_speech" field in the mutation.
func (m *WordMutation) PartOfSpeech() (r string, exists bool) {
	v := m.part_of_speech
	if v == nil {
		return
	}
	return *v, true
}

// OldPartOfSpeech returns the old "part_of_speech" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldPartOfSpeech(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPartOfSpeech is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPartOfSpeech requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartOfSpeech: %w", err)
	}
	return oldValue.PartOfSpeech, nil
}

// ClearPartOfSpeech clears the value of the "part_of_speech" field.
func (m *WordMutation) ClearPartOfSpeech() {
	m.part_of_speech = nil
	m.clearedFields[word.FieldPartOfSpeech] = struct{}{}
}

// PartOfSpeechCleared returns if the "part_of_speech" field was cleared in this mutation.
func (m *WordMutation) PartOfSpeechCleared() bool {
	_, ok := m.clearedFields[word.FieldPartOfSpeech]
	return ok
}

// ResetPartOfSpeech resets all changes to the "part_of_speech" field.
func (m *WordMutation) ResetPartOfSpeech() {
	m.part_of_speech = nil
	delete(m.clearedFields, word.FieldPartOfSpeech)
}

// SetGender sets the "gender" field.
func (m *WordMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *WordMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *WordMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[word.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *WordMutation) GenderCleared() bool {
	_, ok := m.clearedFields[word.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *WordMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, word.FieldGender)
}

// SetFrenchExample sets the "french_example" field.
func (m *WordMutation) SetFrenchExample(s string) {
	m.french_example = &s
}

// FrenchExample returns the value of the "french_example" field in the mutation.
func (m *WordMutation) FrenchExample() (r string, exists bool) {
	v := m.french_example
	if v == nil {
		return
	}
	return *v, true
}

// OldFrenchExample returns the old "french_example" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldFrenchExample(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrenchExample is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrenchExample requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrenchExample: %w", err)
	}
	return oldValue.FrenchExample, nil
}

// ClearFrenchExample clears the value of the "french_example" field.
func (m *WordMutation) ClearFrenchExample() {
	m.french_example = nil
	m.clearedFields[word.FieldFrenchExample] = struct{}{}
}

// FrenchExampleCleared returns if the "french_example" field was cleared in this mutation.
func (m *WordMutation) FrenchExampleCleared() bool {
	_, ok := m.clearedFields[word.FieldFrenchExample]
	return ok
}

// ResetFrenchExample resets all changes to the "french_example" field.
func (m *WordMutation) ResetFrenchExample() {
	m.french_example = nil
	delete(m.clearedFields, word.FieldFrenchExample)
}

// SetEnglishExampleTranslation sets the "english_example_translation" field.
func (m *WordMutation) SetEnglishExampleTranslation(s string) {
	m.english_example_translation = &s
}

// EnglishExampleTranslation returns the value of the "english_example_translation" field in the mutation.
func (m *WordMutation) EnglishExampleTranslation() (r string, exists bool) {
	v := m.english_example_translation
	if v == nil {
		return
	}
	return *v, true
}

// OldEnglishExampleTranslation returns the old "english_example_translation" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldEnglishExampleTranslation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnglishExampleTranslation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnglishExampleTranslation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnglishExampleTranslation: %w", err)
	}
	return oldValue.EnglishExampleTranslation, nil
}

// ClearEnglishExampleTranslation clears the value of the "english_example_translation" field.
func (m *WordMutation) ClearEnglishExampleTranslation() {
	m.english_example_translation = nil
	m.clearedFields[word.FieldEnglishExampleTranslation] = struct{}{}
}

// EnglishExampleTranslationCleared returns if the "english_example_translation" field was cleared in this mutation.
func (m *WordMutation) EnglishExampleTranslationCleared() bool {
	_, ok := m.clearedFields[word.FieldEnglishExampleTranslation]
	return ok
}

// ResetEnglishExampleTranslation resets all changes to the "english_example_translation" field.
func (m *WordMutation) ResetEnglishExampleTranslation() {
	m.english_example_translation = nil
	delete(m.clearedFields, word.FieldEnglishExampleTranslation)
}

// SetPhoneticTranscription sets the "phonetic_transcription" field.
func (m *WordMutation) SetPhoneticTranscription(s string) {
	m.phonetic_transcription = &s
}

// PhoneticTranscription returns the value of the "phonetic_transcription" field in the mutation.
func (m *WordMutation) PhoneticTranscription() (r string, exists bool) {
	v := m.phonetic_transcription
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneticTranscription returns the old "phonetic_transcription" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldPhoneticTranscription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneticTranscription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneticTranscription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneticTranscription: %w", err)
	}
	return oldValue.PhoneticTranscription, nil
}

// ClearPhoneticTranscription clears the value of the "phonetic_transcription" field.
func (m *WordMutation) ClearPhoneticTranscription() {
	m.phonetic_transcription = nil
	m.clearedFields[word.FieldPhoneticTranscription] = struct{}{}
}

// PhoneticTranscriptionCleared returns if the "phonetic_transcription" field was cleared in this mutation.
func (m *WordMutation) PhoneticTranscriptionCleared() bool {
	_, ok := m.clearedFields[word.FieldPhoneticTranscription]
	return ok
}

// ResetPhoneticTranscription resets all changes to the "phonetic_transcription" field.
func (m *WordMutation) ResetPhoneticTranscription() {
	m.phonetic_transcription = nil
	delete(m.clearedFields, word.FieldPhoneticTranscription)
}

// SetPronunciationAudioURL sets the "pronunciation_audio_url" field.
func (m *WordMutation) SetPronunciationAudioURL(s string) {
	m.pronunciation_audio_url = &s
}

// PronunciationAudioURL returns the value of the "pronunciation_audio_url" field in the mutation.
func (m *WordMutation) PronunciationAudioURL() (r string, exists bool) {
	v := m.pronunciation_audio_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPronunciationAudioURL returns the old "pronunciation_audio_url" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldPronunciationAudioURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPronunciationAudioURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPronunciationAudioURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPronunciationAudioURL: %w", err)
	}
	return oldValue.PronunciationAudioURL, nil
}

// ClearPronunciationAudioURL clears the value of the "pronunciation_audio_url" field.
func (m *WordMutation) ClearPronunciationAudioURL() {
	m.pronunciation_audio_url = nil
	m.clearedFields[word.FieldPronunciationAudioURL] = struct{}{}
}

// PronunciationAudioURLCleared returns if the "pronunciation_audio_url" field was cleared in this mutation.
func (m *WordMutation) PronunciationAudioURLCleared() bool {
	_, ok := m.clearedFields[word.FieldPronunciationAudioURL]
	return ok
}

// ResetPronunciationAudioURL resets all changes to the "pronunciation_audio_url" field.
func (m *WordMutation) ResetPronunciationAudioURL() {
	m.pronunciation_audio_url = nil
	delete(m.clearedFields, word.FieldPronunciationAudioURL)
}

// SetDifficultyLevel sets the "difficulty_level" field.
func (m *WordMutation) SetDifficultyLevel(s string) {
	m.difficulty_level = &s
}

// DifficultyLevel returns the value of the "difficulty_level" field in the mutation.
func (m *WordMutation) DifficultyLevel() (r string, exists bool) {
	v := m.difficulty_level
	if v == nil {
		return
	}
	return *v, true
}

// OldDifficultyLevel returns the old "difficulty_level" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldDifficultyLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDifficultyLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDifficultyLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDifficultyLevel: %w", err)
	}
	return oldValue.DifficultyLevel, nil
}

// ClearDifficultyLevel clears the value of the "difficulty_level" field.
func (m *WordMutation) ClearDifficultyLevel() {
	m.difficulty_level = nil
	m.clearedFields[word.FieldDifficultyLevel] = struct{}{}
}

// DifficultyLevelCleared returns if the "difficulty_level" field was cleared in this mutation.
func (m *WordMutation) DifficultyLevelCleared() bool {
	_, ok := m.clearedFields[word.FieldDifficultyLevel]
	return ok
}

// ResetDifficultyLevel resets all changes to the "difficulty_level" field.
func (m *WordMutation) ResetDifficultyLevel() {
	m.difficulty_level = nil
	delete(m.clearedFields, word.FieldDifficultyLevel)
}

// SetTags sets the "tags" field.
func (m *WordMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *WordMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *WordMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *WordMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *WordMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[word.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *WordMutation) TagsCleared() bool {
	_, ok := m.clearedFields[word.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *WordMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, word.FieldTags)
}

// SetUsageContext sets the "usage_context" field.
func (m *WordMutation) SetUsageContext(s string) {
	m.usage_context = &s
}

// UsageContext returns the value of the "usage_context" field in the mutation.
func (m *WordMutation) UsageContext() (r string, exists bool) {
	v := m.usage_context
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageContext returns the old "usage_context" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldUsageContext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageContext: %w", err)
	}
	return oldValue.UsageContext, nil
}

// ClearUsageContext clears the value of the "usage_context" field.
func (m *WordMutation) ClearUsageContext() {
	m.usage_context = nil
	m.clearedFields[word.FieldUsageContext] = struct{}{}
}

// UsageContextCleared returns if the "usage_context" field was cleared in this mutation.
func (m *WordMutation) UsageContextCleared() bool {
	_, ok := m.clearedFields[word.FieldUsageContext]
	return ok
}

// ResetUsageContext resets all changes to the "usage_context" field.
func (m *WordMutation) ResetUsageContext() {
	m.usage_context = nil
	delete(m.clearedFields, word.FieldUsageContext)
}

// SetIsActive sets the "is_active" field.
func (m *WordMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *WordMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *WordMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeckID sets the "deck" edge to the Deck entity by id.
func (m *WordMutation) SetDeckID(id int) {
	m.deck = &id
}

// ClearDeck clears the "deck" edge to the Deck entity.
func (m *WordMutation) ClearDeck() {
	m.cleareddeck = true
}

// DeckCleared reports if the "deck" edge to the Deck entity was cleared.
func (m *WordMutation) DeckCleared() bool {
	return m.cleareddeck
}

// DeckID returns the "deck" edge ID in the mutation.
func (m *WordMutation) DeckID() (id int, exists bool) {
	if m.deck != nil {
		return *m.deck, true
	}
	return
}

// DeckIDs returns the "deck" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeckID instead. It exists only for internal usage by the builders.
func (m *WordMutation) DeckIDs() (ids []int) {
	if id := m.deck; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeck resets all changes to the "deck" edge.
func (m *WordMutation) ResetDeck() {
	m.deck = nil
	m.cleareddeck = false
}

// AddQuestionIDs adds the "questions" edge to the Question entity by ids.
func (m *WordMutation) AddQuestionIDs(ids ...int) {
	if m.questions == nil {
		m.questions = make(map[int]struct{})
	}
	for i := range ids {
		m.questions[ids[i]] = struct{}{}
	}
}

// ClearQuestions clears the "questions" edge to the Question entity.
func (m *WordMutation) ClearQuestions() {
	m.clearedquestions = true
}

// QuestionsCleared reports if the "questions" edge to the Question entity was cleared.
func (m *WordMutation) QuestionsCleared() bool {
	return m.clearedquestions
}

// RemoveQuestionIDs removes the "questions" edge to the Question entity by IDs.
func (m *WordMutation) RemoveQuestionIDs(ids ...int) {
	if m.removedquestions == nil {
		m.removedquestions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.questions, ids[i])
		m.removedquestions[ids[i]] = struct{}{}
	}
}

// RemovedQuestions returns the removed IDs of the "questions" edge to the Question entity.
func (m *WordMutation) RemovedQuestionsIDs() (ids []int) {
	for id := range m.removedquestions {
		ids = append(ids, id)
	}
	return
}

// QuestionsIDs returns the "questions" edge IDs in the mutation.
func (m *WordMutation) QuestionsIDs() (ids []int) {
	for id := range m.questions {
		ids = append(ids, id)
	}
	return
}

// ResetQuestions resets all changes to the "questions" edge.
func (m *WordMutation) ResetQuestions() {
	m.questions = nil
	m.clearedquestions = false
	m.removedquestions = nil
}

// AddPronunciationAttemptIDs adds the "pronunciation_attempts" edge to the PronunciationAttempt entity by ids.
func (m *WordMutation) AddPronunciationAttemptIDs(ids ...int) {
	if m.pronunciation_attempts == nil {
		m.pronunciation_attempts = make(map[int]struct{})
	}
	for i := range ids {
		m.pronunciation_attempts[ids[i]] = struct{}{}
	}
}

// ClearPronunciationAttempts clears the "pronunciation_attempts" edge to the PronunciationAttempt entity.
func (m *WordMutation) ClearPronunciationAttempts() {
	m.clearedpronunciation_attempts = true
}

// PronunciationAttemptsCleared reports if the "pronunciation_attempts" edge to the PronunciationAttempt entity was cleared.
func (m *WordMutation) PronunciationAttemptsCleared() bool {
	return m.clearedpronunciation_attempts
}

// RemovePronunciationAttemptIDs removes the "pronunciation_attempts" edge to the PronunciationAttempt entity by IDs.
func (m *WordMutation) RemovePronunciationAttemptIDs(ids ...int) {
	if m.removedpronunciation_attempts == nil {
		m.removedpronunciation_attempts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pronunciation_attempts, ids[i])
		m.removedpronunciation_attempts[ids[i]] = struct{}{}
	}
}

// RemovedPronunciationAttempts returns the removed IDs of the "pronunciation_attempts" edge to the PronunciationAttempt entity.
func (m *WordMutation) RemovedPronunciationAttemptsIDs() (ids []int) {
	for id := range m.removedpronunciation_attempts {
		ids = append(ids, id)
	}
	return
}

// PronunciationAttemptsIDs returns the "pronunciation_attempts" edge IDs in the mutation.
func (m *WordMutation) PronunciationAttemptsIDs() (ids []int) {
	for id := range m.pronunciation_attempts {
		ids = append(ids, id)
	}
	return
}

// ResetPronunciationAttempts resets all changes to the "pronunciation_attempts" edge.
func (m *WordMutation) ResetPronunciationAttempts() {
	m.pronunciation_attempts = nil
	m.clearedpronunciation_attempts = false
	m.removedpronunciation_attempts = nil
}

// Where appends a list predicates to the WordMutation builder.
func (m *WordMutation) Where(ps ...predicate.Word) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Word, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Word).
func (m *WordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WordMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.french_word != nil {
		fields = append(fields, word.FieldFrenchWord)
	}
	if m.english_translation != nil {
		fields = append(fields, word.FieldEnglishTranslation)
	}
	if m.part_of_speech != nil {
		fields = append(fields, word.FieldPartOfSpeech)
	}
	if m.gender != nil {
		fields = append(fields, word.FieldGender)
	}
	if m.french_example != nil {
		fields = append(fields, word.FieldFrenchExample)
	}
	if m.english_example_translation != nil {
		fields = append(fields, word.FieldEnglishExampleTranslation)
	}
	if m.phonetic_transcription != nil {
		fields = append(fields, word.FieldPhoneticTranscription)
	}
	if m.pronunciation_audio_url != nil {
		fields = append(fields, word.FieldPronunciationAudioURL)
	}
	if m.difficulty_level != nil {
		fields = append(fields, word.FieldDifficultyLevel)
	}
	if m.tags != nil {
		fields = append(fields, word.FieldTags)
	}
	if m.usage_context != nil {
		fields = append(fields, word.FieldUsageContext)
	}
	if m.is_active != nil {
		fields = append(fields, word.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, word.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, word.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case word.FieldFrenchWord:
		return m.FrenchWord()
	case word.FieldEnglishTranslation:
		return m.EnglishTranslation()
	case word.FieldPartOfSpeech:
		return m.PartOfSpeech()
	case word.FieldGender:
		return m.Gender()
	case word.FieldFrenchExample:
		return m.FrenchExample()
	case word.FieldEnglishExampleTranslation:
		return m.EnglishExampleTranslation()
	case word.FieldPhoneticTranscription:
		return m.PhoneticTranscription()
	case word.FieldPronunciationAudioURL:
		return m.PronunciationAudioURL()
	case word.FieldDifficultyLevel:
		return m.DifficultyLevel()
	case word.FieldTags:
		return m.Tags()
	case word.FieldUsageContext:
		return m.UsageContext()
	case word.FieldIsActive:
		return m.IsActive()
	case word.FieldCreatedAt:
		return m.CreatedAt()
	case word.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case word.FieldFrenchWord:
		return m.OldFrenchWord(ctx)
	case word.FieldEnglishTranslation:
		return m.OldEnglishTranslation(ctx)
	case word.FieldPartOfSpeech:
		return m.OldPartOfSpeech(ctx)
	case word.FieldGender:
		return m.OldGender(ctx)
	case word.FieldFrenchExample:
		return m.OldFrenchExample(ctx)
	case word.FieldEnglishExampleTranslation:
		return m.OldEnglishExampleTranslation(ctx)
	case word.FieldPhoneticTranscription:
		return m.OldPhoneticTranscription(ctx)
	case word.FieldPronunciationAudioURL:
		return m.OldPronunciationAudioURL(ctx)
	case word.FieldDifficultyLevel:
		return m.OldDifficultyLevel(ctx)
	case word.FieldTags:
		return m.OldTags(ctx)
	case word.FieldUsageContext:
		return m.OldUsageContext(ctx)
	case word.FieldIsActive:
		return m.OldIsActive(ctx)
	case word.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case word.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Word field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case word.FieldFrenchWord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrenchWord(v)
		return nil
	case word.FieldEnglishTranslation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnglishTranslation(v)
		return nil
	case word.FieldPartOfSpeech:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartOfSpeech(v)
		return nil
	case word.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case word.FieldFrenchExample:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrenchExample(v)
		return nil
	case word.FieldEnglishExampleTranslation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnglishExampleTranslation(v)
		return nil
	case word.FieldPhoneticTranscription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneticTranscription(v)
		return nil
	case word.FieldPronunciationAudioURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPronunciationAudioURL(v)
		return nil
	case word.FieldDifficultyLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDifficultyLevel(v)
		return nil
	case word.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case word.FieldUsageContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageContext(v)
		return nil
	case word.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case word.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case word.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Word field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Word numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(word.FieldPartOfSpeech) {
		fields = append(fields, word.FieldPartOfSpeech)
	}
	if m.FieldCleared(word.FieldGender) {
		fields = append(fields, word.FieldGender)
	}
	if m.FieldCleared(word.FieldFrenchExample) {
		fields = append(fields, word.FieldFrenchExample)
	}
	if m.FieldCleared(word.FieldEnglishExampleTranslation) {
		fields = append(fields, word.FieldEnglishExampleTranslation)
	}
	if m.FieldCleared(word.FieldPhoneticTranscription) {
		fields = append(fields, word.FieldPhoneticTranscription)
	}
	if m.FieldCleared(word.FieldPronunciationAudioURL) {
		fields = append(fields, word.FieldPronunciationAudioURL)
	}
	if m.FieldCleared(word.FieldDifficultyLevel) {
		fields = append(fields, word.FieldDifficultyLevel)
	}
	if m.FieldCleared(word.FieldTags) {
		fields = append(fields, word.FieldTags)
	}
	if m.FieldCleared(word.FieldUsageContext) {
		fields = append(fields, word.FieldUsageContext)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WordMutation) ClearField(name string) error {
	switch name {
	case word.FieldPartOfSpeech:
		m.ClearPartOfSpeech()
		return nil
	case word.FieldGender:
		m.ClearGender()
		return nil
	case word.FieldFrenchExample:
		m.ClearFrenchExample()
		return nil
	case word.FieldEnglishExampleTranslation:
		m.ClearEnglishExampleTranslation()
		return nil
	case word.FieldPhoneticTranscription:
		m.ClearPhoneticTranscription()
		return nil
	case word.FieldPronunciationAudioURL:
		m.ClearPronunciationAudioURL()
		return nil
	case word.FieldDifficultyLevel:
		m.ClearDifficultyLevel()
		return nil
	case word.FieldTags:
		m.ClearTags()
		return nil
	case word.FieldUsageContext:
		m.ClearUsageContext()
		return nil
	}
	return fmt.Errorf("unknown Word nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WordMutation) ResetField(name string) error {
	switch name {
	case word.FieldFrenchWord:
		m.ResetFrenchWord()
		return nil
	case word.FieldEnglishTranslation:
		m.ResetEnglishTranslation()
		return nil
	case word.FieldPartOfSpeech:
		m.ResetPartOfSpeech()
		return nil
	case word.FieldGender:
		m.ResetGender()
		return nil
	case word.FieldFrenchExample:
		m.ResetFrenchExample()
		return nil
	case word.FieldEnglishExampleTranslation:
		m.ResetEnglishExampleTranslation()
		return nil
	case word.FieldPhoneticTranscription:
		m.ResetPhoneticTranscription()
		return nil
	case word.FieldPronunciationAudioURL:
		m.ResetPronunciationAudioURL()
		return nil
	case word.FieldDifficultyLevel:
		m.ResetDifficultyLevel()
		return nil
	case word.FieldTags:
		m.ResetTags()
		return nil
	case word.FieldUsageContext:
		m.ResetUsageContext()
		return nil
	case word.FieldIsActive:
		m.ResetIsActive()
		return nil
	case word.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case word.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Word field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WordMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.deck != nil {
		edges = append(edges, word.EdgeDeck)
	}
	if m.questions != nil {
		edges = append(edges, word.EdgeQuestions)
	}
	if m.pronunciation_attempts != nil {
		edges = append(edges, word.EdgePronunciationAttempts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case word.EdgeDeck:
		if id := m.deck; id != nil {
			return []ent.Value{*id}
		}
	case word.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.questions))
		for id := range m.questions {
			ids = append(ids, id)
		}
		return ids
	case word.EdgePronunciationAttempts:
		ids := make([]ent.Value, 0, len(m.pronunciation_attempts))
		for id := range m.pronunciation_attempts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedquestions != nil {
		edges = append(edges, word.EdgeQuestions)
	}
	if m.removedpronunciation_attempts != nil {
		edges = append(edges, word.EdgePronunciationAttempts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case word.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.removedquestions))
		for id := range m.removedquestions {
			ids = append(ids, id)
		}
		return ids
	case word.EdgePronunciationAttempts:
		ids := make([]ent.Value, 0, len(m.removedpronunciation_attempts))
		for id := range m.removedpronunciation_attempts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddeck {
		edges = append(edges, word.EdgeDeck)
	}
	if m.clearedquestions {
		edges = append(edges, word.EdgeQuestions)
	}
	if m.clearedpronunciation_attempts {
		edges = append(edges, word.EdgePronunciationAttempts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WordMutation) EdgeCleared(name string) bool {
	switch name {
	case word.EdgeDeck:
		return m.cleareddeck
	case word.EdgeQuestions:
		return m.clearedquestions
	case word.EdgePronunciationAttempts:
		return m.clearedpronunciation_attempts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WordMutation) ClearEdge(name string) error {
	switch name {
	case word.EdgeDeck:
		m.ClearDeck()
		return nil
	}
	return fmt.Errorf("unknown Word unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WordMutation) ResetEdge(name string) error {
	switch name {
	case word.EdgeDeck:
		m.ResetDeck()
		return nil
	case word.EdgeQuestions:
		m.ResetQuestions()
		return nil
	case word.EdgePronunciationAttempts:
		m.ResetPronunciationAttempts()
		return nil
	}
	return fmt.Errorf("unknown Word edge %s", name)
}
